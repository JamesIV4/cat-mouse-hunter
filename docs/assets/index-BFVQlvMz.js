var hi=Object.defineProperty;var ui=(y,t,e)=>t in y?hi(y,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):y[t]=e;var j=(y,t,e)=>ui(y,typeof t!="symbol"?t+"":t,e);import*as g from"three";import{Vector4 as mn,Vector3 as Wt,Curve as di,Loader as jn,LoaderUtils as pi,FileLoader as fi,TextureLoader as mi,RepeatWrapping as os,ClampToEdgeWrapping as rs,Texture as An,MeshPhongMaterial as En,MeshLambertMaterial as yi,Color as he,SRGBColorSpace as en,EquirectangularReflectionMapping as wi,Matrix4 as xt,Group as as,Bone as cs,PropertyBinding as un,Object3D as Sn,OrthographicCamera as xi,PerspectiveCamera as gi,PointLight as ls,MathUtils as Rt,SpotLight as vi,DirectionalLight as bi,SkinnedMesh as Mi,Mesh as zi,LineBasicMaterial as Ai,Line as Ei,Skeleton as Si,AmbientLight as Ci,BufferGeometry as Cn,Float32BufferAttribute as Pe,Uint16BufferAttribute as Bi,Matrix3 as Ti,Vector2 as Pi,ShapeUtils as Ii,Euler as ee,AnimationClip as Fi,Quaternion as me,VectorKeyframeTrack as Ri,QuaternionKeyframeTrack as hs,NumberKeyframeTrack as Li}from"three";import*as ki from"three/examples/jsm/utils/SkeletonUtils.js";(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=e(s);fetch(s.href,i)}})();class Zt{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new d);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new d);const n=this.elements,s=t.x,i=t.y,o=t.z;return e.x=n[0]*s+n[1]*i+n[2]*o,e.y=n[3]*s+n[4]*i+n[5]*o,e.z=n[6]*s+n[7]*i+n[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new Zt);const n=this.elements,s=t.elements,i=e.elements,o=n[0],r=n[1],a=n[2],c=n[3],l=n[4],u=n[5],h=n[6],f=n[7],p=n[8],w=s[0],m=s[1],v=s[2],x=s[3],M=s[4],E=s[5],P=s[6],S=s[7],V=s[8];return i[0]=o*w+r*x+a*P,i[1]=o*m+r*M+a*S,i[2]=o*v+r*E+a*V,i[3]=c*w+l*x+u*P,i[4]=c*m+l*M+u*S,i[5]=c*v+l*E+u*V,i[6]=h*w+f*x+p*P,i[7]=h*m+f*M+p*S,i[8]=h*v+f*E+p*V,e}scale(t,e){e===void 0&&(e=new Zt);const n=this.elements,s=e.elements;for(let i=0;i!==3;i++)s[3*i+0]=t.x*n[3*i+0],s[3*i+1]=t.y*n[3*i+1],s[3*i+2]=t.z*n[3*i+2];return e}solve(t,e){e===void 0&&(e=new d);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=t.x,i[3+4*1]=t.y,i[3+4*2]=t.z;let a=3;const c=a;let l;const u=4;let h;do{if(o=c-a,i[o+s*o]===0){for(r=o+1;r<c;r++)if(i[o+s*r]!==0){l=u;do h=u-l,i[h+s*o]+=i[h+s*r];while(--l);break}}if(i[o+s*o]!==0)for(r=o+1;r<c;r++){const f=i[o+s*r]/i[o+s*o];l=u;do h=u-l,i[h+s*r]=h<=o?0:i[h+s*r]-i[h+s*o]*f;while(--l)}}while(--a);if(e.z=i[2*s+3]/i[2*s+2],e.y=(i[1*s+3]-i[1*s+2]*e.z)/i[1*s+1],e.x=(i[0*s+3]-i[0*s+2]*e.z-i[0*s+1]*e.y)/i[0*s+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,n){if(n===void 0)return this.elements[e+3*t];this.elements[e+3*t]=n}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let n=0;n<9;n++)t+=this.elements[n]+e;return t}reverse(t){t===void 0&&(t=new Zt);const e=3,n=6,s=Vi;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const a=r;let c;const l=n;let u;do{if(i=a-r,s[i+n*i]===0){for(o=i+1;o<a;o++)if(s[i+n*o]!==0){c=l;do u=l-c,s[u+n*i]+=s[u+n*o];while(--c);break}}if(s[i+n*i]!==0)for(o=i+1;o<a;o++){const h=s[i+n*o]/s[i+n*i];c=l;do u=l-c,s[u+n*o]=u<=i?0:s[u+n*o]-s[u+n*i]*h;while(--c)}}while(--r);i=2;do{o=i-1;do{const h=s[i+n*o]/s[i+n*i];c=n;do u=n-c,s[u+n*o]=s[u+n*o]-s[u+n*i]*h;while(--c)}while(o--)}while(--i);i=2;do{const h=1/s[i+n*i];c=n;do u=n-c,s[u+n*i]=s[u+n*i]*h;while(--c)}while(i--);i=2;do{o=2;do{if(u=s[e+o+n*i],isNaN(u)||u===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,o,u)}while(o--)}while(i--);return t}setRotationFromQuaternion(t){const e=t.x,n=t.y,s=t.z,i=t.w,o=e+e,r=n+n,a=s+s,c=e*o,l=e*r,u=e*a,h=n*r,f=n*a,p=s*a,w=i*o,m=i*r,v=i*a,x=this.elements;return x[3*0+0]=1-(h+p),x[3*0+1]=l-v,x[3*0+2]=u+m,x[3*1+0]=l+v,x[3*1+1]=1-(c+p),x[3*1+2]=f-w,x[3*2+0]=u-m,x[3*2+1]=f+w,x[3*2+2]=1-(c+h),this}transpose(t){t===void 0&&(t=new Zt);const e=this.elements,n=t.elements;let s;return n[0]=e[0],n[4]=e[4],n[8]=e[8],s=e[1],n[1]=e[3],n[3]=s,s=e[2],n[2]=e[6],n[6]=s,s=e[5],n[5]=e[7],n[7]=s,t}}const Vi=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class d{constructor(t,e,n){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),this.x=t,this.y=e,this.z=n}cross(t,e){e===void 0&&(e=new d);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z;return e.x=r*i-a*s,e.y=a*n-o*i,e.z=o*s-r*n,e}set(t,e,n){return this.x=t,this.y=e,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new d(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new d(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new Zt([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,n=this.z,s=Math.sqrt(t*t+e*e+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(t){t===void 0&&(t=new d);const e=this.x,n=this.y,s=this.z;let i=Math.sqrt(e*e+n*n+s*s);return i>0?(i=1/i,t.x=e*i,t.y=n*i,t.z=s*i):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,n=this.z;return Math.sqrt(t*t+e*e+n*n)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return Math.sqrt((i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return(i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s)}scale(t,e){e===void 0&&(e=new d);const n=this.x,s=this.y,i=this.z;return e.x=t*n,e.y=t*s,e.z=t*i,e}vmul(t,e){return e===void 0&&(e=new d),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,n){return n===void 0&&(n=new d),n.x=this.x+t*e.x,n.y=this.y+t*e.y,n.z=this.z+t*e.z,n}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new d),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const n=this.length();if(n>0){const s=Di,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=Ni;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,t)):(o.set(0,1,0),s.cross(o,t)),s.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,n){const s=this.x,i=this.y,o=this.z;n.x=s+(t.x-s)*e,n.y=i+(t.y-i)*e,n.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(us),us.almostEquals(t,e)}clone(){return new d(this.x,this.y,this.z)}}d.ZERO=new d(0,0,0);d.UNIT_X=new d(1,0,0);d.UNIT_Y=new d(0,1,0);d.UNIT_Z=new d(0,0,1);const Di=new d,Ni=new d,us=new d;class Ot{constructor(t){t===void 0&&(t={}),this.lowerBound=new d,this.upperBound=new d,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(t[0]),r&&r.vmult(i,i),o.copy(i);for(let a=1;a<t.length;a++){let c=t[a];r&&(r.vmult(c,ds),c=ds),c.x>o.x&&(o.x=c.x),c.x<i.x&&(i.x=c.x),c.y>o.y&&(o.y=c.y),c.y<i.y&&(i.y=c.y),c.z>o.z&&(o.z=c.z),c.z<i.z&&(i.z=c.z)}return e&&(e.vadd(i,i),e.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new Ot().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound,o=s.x<=n.x&&n.x<=i.x||e.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||e.y<=i.y&&i.y<=n.y,a=s.z<=n.z&&n.z<=i.z||e.z<=i.z&&i.z<=n.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound;return e.x<=s.x&&n.x>=i.x&&e.y<=s.y&&n.y>=i.y&&e.z<=s.z&&n.z>=i.z}getCorners(t,e,n,s,i,o,r,a){const c=this.lowerBound,l=this.upperBound;t.copy(c),e.set(l.x,c.y,c.z),n.set(l.x,l.y,c.z),s.set(c.x,l.y,l.z),i.set(l.x,c.y,l.z),o.set(c.x,l.y,c.z),r.set(c.x,c.y,l.z),a.copy(l)}toLocalFrame(t,e){const n=ps,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],l=n[6],u=n[7];this.getCorners(s,i,o,r,a,c,l,u);for(let h=0;h!==8;h++){const f=n[h];t.pointToLocal(f,f)}return e.setFromPoints(n)}toWorldFrame(t,e){const n=ps,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],l=n[6],u=n[7];this.getCorners(s,i,o,r,a,c,l,u);for(let h=0;h!==8;h++){const f=n[h];t.pointToWorld(f,f)}return e.setFromPoints(n)}overlapsRay(t){const{direction:e,from:n}=t,s=1/e.x,i=1/e.y,o=1/e.z,r=(this.lowerBound.x-n.x)*s,a=(this.upperBound.x-n.x)*s,c=(this.lowerBound.y-n.y)*i,l=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*o,h=(this.upperBound.z-n.z)*o,f=Math.max(Math.max(Math.min(r,a),Math.min(c,l)),Math.min(u,h)),p=Math.min(Math.min(Math.max(r,a),Math.max(c,l)),Math.max(u,h));return!(p<0||f>p)}}const ds=new d,ps=[new d,new d,new d,new d,new d,new d,new d,new d];class fs{constructor(){this.matrix=[]}get(t,e){let{index:n}=t,{index:s}=e;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(t,e,n){let{index:s}=t,{index:i}=e;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class Vs{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[t]===void 0&&(n[t]=[]),n[t].includes(e)||n[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[t]!==void 0&&n[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const n=this._listeners;if(n[t]===void 0)return this;const s=n[t].indexOf(e);return s!==-1&&n[t].splice(s,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const n=this._listeners[t.type];if(n!==void 0){t.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,t)}return this}}class bt{constructor(t,e,n,s){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=t,this.y=e,this.z=n,this.w=s}set(t,e,n,s){return this.x=t,this.y=e,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const n=Math.sin(e*.5);return this.x=t.x*n,this.y=t.y*n,this.z=t.z*n,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new d),this.normalize();const e=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/n,t.y=this.y/n,t.z=this.z/n),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const n=Oi,s=qi;t.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=t.cross(e);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new bt);const n=this.x,s=this.y,i=this.z,o=this.w,r=t.x,a=t.y,c=t.z,l=t.w;return e.x=n*l+o*r+s*c-i*a,e.y=s*l+o*a+i*r-n*c,e.z=i*l+o*c+n*a-s*r,e.w=o*l-n*r-s*a-i*c,e}inverse(t){t===void 0&&(t=new bt);const e=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(t);const o=1/(e*e+n*n+s*s+i*i);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new bt),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new d);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z,c=this.w,l=c*n+r*i-a*s,u=c*s+a*n-o*i,h=c*i+o*s-r*n,f=-o*n-r*s-a*i;return e.x=l*c+f*-o+u*-a-h*-r,e.y=u*c+f*-r+h*-o-l*-a,e.z=h*c+f*-a+l*-r-u*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let n,s,i;const o=this.x,r=this.y,a=this.z,c=this.w;switch(e){case"YZX":const l=o*r+a*c;if(l>.499&&(n=2*Math.atan2(o,c),s=Math.PI/2,i=0),l<-.499&&(n=-2*Math.atan2(o,c),s=-Math.PI/2,i=0),n===void 0){const u=o*o,h=r*r,f=a*a;n=Math.atan2(2*r*c-2*o*a,1-2*h-2*f),s=Math.asin(2*l),i=Math.atan2(2*o*c-2*r*a,1-2*u-2*f)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=n,t.z=s,t.x=i}setFromEuler(t,e,n,s){s===void 0&&(s="XYZ");const i=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(n/2),a=Math.sin(t/2),c=Math.sin(e/2),l=Math.sin(n/2);return s==="XYZ"?(this.x=a*o*r+i*c*l,this.y=i*c*r-a*o*l,this.z=i*o*l+a*c*r,this.w=i*o*r-a*c*l):s==="YXZ"?(this.x=a*o*r+i*c*l,this.y=i*c*r-a*o*l,this.z=i*o*l-a*c*r,this.w=i*o*r+a*c*l):s==="ZXY"?(this.x=a*o*r-i*c*l,this.y=i*c*r+a*o*l,this.z=i*o*l+a*c*r,this.w=i*o*r-a*c*l):s==="ZYX"?(this.x=a*o*r-i*c*l,this.y=i*c*r+a*o*l,this.z=i*o*l-a*c*r,this.w=i*o*r+a*c*l):s==="YZX"?(this.x=a*o*r+i*c*l,this.y=i*c*r+a*o*l,this.z=i*o*l-a*c*r,this.w=i*o*r-a*c*l):s==="XZY"&&(this.x=a*o*r-i*c*l,this.y=i*c*r-a*o*l,this.z=i*o*l+a*c*r,this.w=i*o*r+a*c*l),this}clone(){return new bt(this.x,this.y,this.z,this.w)}slerp(t,e,n){n===void 0&&(n=new bt);const s=this.x,i=this.y,o=this.z,r=this.w;let a=t.x,c=t.y,l=t.z,u=t.w,h,f,p,w,m;return f=s*a+i*c+o*l+r*u,f<0&&(f=-f,a=-a,c=-c,l=-l,u=-u),1-f>1e-6?(h=Math.acos(f),p=Math.sin(h),w=Math.sin((1-e)*h)/p,m=Math.sin(e*h)/p):(w=1-e,m=e),n.x=w*s+m*a,n.y=w*i+m*c,n.z=w*o+m*l,n.w=w*r+m*u,n}integrate(t,e,n,s){s===void 0&&(s=new bt);const i=t.x*n.x,o=t.y*n.y,r=t.z*n.z,a=this.x,c=this.y,l=this.z,u=this.w,h=e*.5;return s.x+=h*(i*u+o*l-r*c),s.y+=h*(o*u+r*a-i*l),s.z+=h*(r*u+i*c-o*a),s.w+=h*(-i*a-o*c-r*l),s}}const Oi=new d,qi=new d,Gi={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class X{constructor(t){t===void 0&&(t={}),this.id=X.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}X.idCounter=0;X.types=Gi;class at{constructor(t){t===void 0&&(t={}),this.position=new d,this.quaternion=new bt,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return at.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return at.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new d),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,n,s){return s===void 0&&(s=new d),n.vsub(t,s),e.conjugate(ms),ms.vmult(s,s),s}static pointToWorldFrame(t,e,n,s){return s===void 0&&(s=new d),e.vmult(n,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,n){return n===void 0&&(n=new d),t.vmult(e,n),n}static vectorToLocalFrame(t,e,n,s){return s===void 0&&(s=new d),e.w*=-1,e.vmult(n,s),e.w*=-1,s}}const ms=new bt;class Le extends X{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=t;super({type:X.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,n=this.uniqueEdges;n.length=0;const s=new d;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let a=0;a!==r;a++){const c=(a+1)%r;e[o[a]].vsub(e[o[c]],s),s.normalize();let l=!1;for(let u=0;u!==n.length;u++)if(n[u].almostEquals(s)||n[u].almostEquals(s)){l=!0;break}l||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const e=this.faceNormals[t]||new d;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const n=this.vertices[this.faces[t][0]];if(e.dot(n)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,e){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];Le.computeNormal(s,i,o,e)}static computeNormal(t,e,n,s){const i=new d,o=new d;e.vsub(t,o),n.vsub(e,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,n,s,i,o,r,a,c){const l=new d;let u=-1,h=-Number.MAX_VALUE;for(let p=0;p<n.faces.length;p++){l.copy(n.faceNormals[p]),i.vmult(l,l);const w=l.dot(o);w>h&&(h=w,u=p)}const f=[];for(let p=0;p<n.faces[u].length;p++){const w=n.vertices[n.faces[u][p]],m=new d;m.copy(w),i.vmult(m,m),s.vadd(m,m),f.push(m)}u>=0&&this.clipFaceAgainstHull(o,t,e,f,r,a,c)}findSeparatingAxis(t,e,n,s,i,o,r,a){const c=new d,l=new d,u=new d,h=new d,f=new d,p=new d;let w=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let v=0;v!==m.uniqueAxes.length;v++){n.vmult(m.uniqueAxes[v],c);const x=m.testSepAxis(c,t,e,n,s,i);if(x===!1)return!1;x<w&&(w=x,o.copy(c))}else{const v=r?r.length:m.faces.length;for(let x=0;x<v;x++){const M=r?r[x]:x;c.copy(m.faceNormals[M]),n.vmult(c,c);const E=m.testSepAxis(c,t,e,n,s,i);if(E===!1)return!1;E<w&&(w=E,o.copy(c))}}if(t.uniqueAxes)for(let v=0;v!==t.uniqueAxes.length;v++){i.vmult(t.uniqueAxes[v],l);const x=m.testSepAxis(l,t,e,n,s,i);if(x===!1)return!1;x<w&&(w=x,o.copy(l))}else{const v=a?a.length:t.faces.length;for(let x=0;x<v;x++){const M=a?a[x]:x;l.copy(t.faceNormals[M]),i.vmult(l,l);const E=m.testSepAxis(l,t,e,n,s,i);if(E===!1)return!1;E<w&&(w=E,o.copy(l))}}for(let v=0;v!==m.uniqueEdges.length;v++){n.vmult(m.uniqueEdges[v],h);for(let x=0;x!==t.uniqueEdges.length;x++)if(i.vmult(t.uniqueEdges[x],f),h.cross(f,p),!p.almostZero()){p.normalize();const M=m.testSepAxis(p,t,e,n,s,i);if(M===!1)return!1;M<w&&(w=M,o.copy(p))}}return s.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,n,s,i,o){const r=this;Le.project(r,t,n,s,Bn),Le.project(e,t,i,o,Tn);const a=Bn[0],c=Bn[1],l=Tn[0],u=Tn[1];if(a<u||l<c)return!1;const h=a-u,f=l-c;return h<f?h:f}calculateLocalInertia(t,e){const n=new d,s=new d;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*i*2*i+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],n=this.faceNormals[t],s=this.vertices[e[0]];return-n.dot(s)}clipFaceAgainstHull(t,e,n,s,i,o,r){const a=new d,c=new d,l=new d,u=new d,h=new d,f=new d,p=new d,w=new d,m=this,v=[],x=s,M=v;let E=-1,P=Number.MAX_VALUE;for(let I=0;I<m.faces.length;I++){a.copy(m.faceNormals[I]),n.vmult(a,a);const W=a.dot(t);W<P&&(P=W,E=I)}if(E<0)return;const S=m.faces[E];S.connectedFaces=[];for(let I=0;I<m.faces.length;I++)for(let W=0;W<m.faces[I].length;W++)S.indexOf(m.faces[I][W])!==-1&&I!==E&&S.connectedFaces.indexOf(I)===-1&&S.connectedFaces.push(I);const V=S.length;for(let I=0;I<V;I++){const W=m.vertices[S[I]],_=m.vertices[S[(I+1)%V]];W.vsub(_,c),l.copy(c),n.vmult(l,l),e.vadd(l,l),u.copy(this.faceNormals[E]),n.vmult(u,u),e.vadd(u,u),l.cross(u,h),h.negate(h),f.copy(W),n.vmult(f,f),e.vadd(f,f);const z=S.connectedFaces[I];p.copy(this.faceNormals[z]);const R=this.getPlaneConstantOfFace(z);w.copy(p),n.vmult(w,w);const k=R-w.dot(e);for(this.clipFaceAgainstPlane(x,M,w,k);x.length;)x.shift();for(;M.length;)x.push(M.shift())}p.copy(this.faceNormals[E]);const O=this.getPlaneConstantOfFace(E);w.copy(p),n.vmult(w,w);const K=O-w.dot(e);for(let I=0;I<x.length;I++){let W=w.dot(x[I])+K;if(W<=i&&(console.log(`clamped: depth=${W} to minDist=${i}`),W=i),W<=o){const _=x[I];if(W<=1e-6){const z={point:_,normal:w,depth:W};r.push(z)}}}}clipFaceAgainstPlane(t,e,n,s){let i,o;const r=t.length;if(r<2)return e;let a=t[t.length-1],c=t[0];i=n.dot(a)+s;for(let l=0;l<r;l++){if(c=t[l],o=n.dot(c)+s,i<0)if(o<0){const u=new d;u.copy(c),e.push(u)}else{const u=new d;a.lerp(c,i/(i-o),u),e.push(u)}else if(o<0){const u=new d;a.lerp(c,i/(i-o),u),e.push(u),e.push(c)}a=c,i=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new d);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(n[i],s[i]),t.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const n=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<t.x?t.x=i.x:i.x>e.x&&(e.x=i.x),i.y<t.y?t.y=i.y:i.y>e.y&&(e.y=i.y),i.z<t.z?t.z=i.z:i.z>e.z&&(e.z=i.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new d);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let n=0;n!==e.length;n++){const s=e[n].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,n,s){const i=this.vertices;let o,r,a,c,l,u,h=new d;for(let f=0;f<i.length;f++){h.copy(i[f]),e.vmult(h,h),t.vadd(h,h);const p=h;(o===void 0||p.x<o)&&(o=p.x),(c===void 0||p.x>c)&&(c=p.x),(r===void 0||p.y<r)&&(r=p.y),(l===void 0||p.y>l)&&(l=p.y),(a===void 0||p.z<a)&&(a=p.z),(u===void 0||p.z>u)&&(u=p.z)}n.set(o,r,a),s.set(c,l,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new d);const e=this.vertices;for(let n=0;n<e.length;n++)t.vadd(e[n],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const n=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<n;i++){const o=s[i];e.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];e.vmult(o,o)}}if(t)for(let i=0;i<n;i++){const o=s[i];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,n=this.faces,s=this.faceNormals,i=new d;this.getAveragePointLocal(i);for(let o=0;o<this.faces.length;o++){let r=s[o];const a=e[n[o][0]],c=new d;t.vsub(a,c);const l=r.dot(c),u=new d;i.vsub(a,u);const h=r.dot(u);if(l<0&&h>0||l>0&&h<0)return!1}return-1}static project(t,e,n,s,i){const o=t.vertices.length,r=_i;let a=0,c=0;const l=Hi,u=t.vertices;l.setZero(),at.vectorToLocalFrame(n,s,e,r),at.pointToLocalFrame(n,s,l,l);const h=l.dot(r);c=a=u[0].dot(r);for(let f=1;f<o;f++){const p=u[f].dot(r);p>a&&(a=p),p<c&&(c=p)}if(c-=h,a-=h,c>a){const f=c;c=a,a=f}i[0]=a,i[1]=c}}const Bn=[],Tn=[];new d;const _i=new d,Hi=new d;class Nt extends X{constructor(t){super({type:X.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,n=this.halfExtents.z,s=d,i=[new s(-t,-e,-n),new s(t,-e,-n),new s(t,e,-n),new s(-t,e,-n),new s(-t,-e,n),new s(t,-e,n),new s(t,e,n),new s(-t,e,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],a=new Le({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new d),Nt.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,n){const s=t;n.x=1/12*e*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*e*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*e*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(t,e){const n=t,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),e!==void 0)for(let i=0;i!==n.length;i++)e.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)ye.set(i[o][0],i[o][1],i[o][2]),e.vmult(ye,ye),t.vadd(ye,ye),n(ye.x,ye.y,ye.z)}calculateWorldAABB(t,e,n,s){const i=this.halfExtents;$t[0].set(i.x,i.y,i.z),$t[1].set(-i.x,i.y,i.z),$t[2].set(-i.x,-i.y,i.z),$t[3].set(-i.x,-i.y,-i.z),$t[4].set(i.x,-i.y,-i.z),$t[5].set(i.x,i.y,-i.z),$t[6].set(-i.x,i.y,-i.z),$t[7].set(i.x,-i.y,i.z);const o=$t[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const a=$t[r];e.vmult(a,a),t.vadd(a,a);const c=a.x,l=a.y,u=a.z;c>s.x&&(s.x=c),l>s.y&&(s.y=l),u>s.z&&(s.z=u),c<n.x&&(n.x=c),l<n.y&&(n.y=l),u<n.z&&(n.z=u)}}}const ye=new d,$t=[new d,new d,new d,new d,new d,new d,new d,new d],Kn={DYNAMIC:1,STATIC:2,KINEMATIC:4},Zn={AWAKE:0,SLEEPY:1,SLEEPING:2};class H extends Vs{constructor(t){t===void 0&&(t={}),super(),this.id=H.idCounter++,this.index=-1,this.world=null,this.vlambda=new d,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new d,this.previousPosition=new d,this.interpolatedPosition=new d,this.initPosition=new d,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new d,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new d,this.force=new d;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?H.STATIC:H.DYNAMIC,typeof t.type==typeof H.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=H.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new d,this.quaternion=new bt,this.initQuaternion=new bt,this.previousQuaternion=new bt,this.interpolatedQuaternion=new bt,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new d,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new d,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new d,this.invInertia=new d,this.invInertiaWorld=new Zt,this.invMassSolve=0,this.invInertiaSolve=new d,this.invInertiaWorldSolve=new Zt,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new d(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new d(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new Ot,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new d,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=H.AWAKE,this.wakeUpAfterNarrowphase=!1,t===H.SLEEPING&&this.dispatchEvent(H.wakeupEvent)}sleep(){this.sleepState=H.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===H.AWAKE&&n<s?(this.sleepState=H.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(H.sleepyEvent)):e===H.SLEEPY&&n>s?this.wakeUp():e===H.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(H.sleepEvent))}}updateSolveMassProperties(){this.sleepState===H.SLEEPING||this.type===H.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new d),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new d),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new d),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new d),this.quaternion.vmult(t,e),e}addShape(t,e,n){const s=new d,i=new bt;return e&&s.copy(e),n&&i.copy(n),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,n=t.length;let s=0;for(let i=0;i!==n;i++){const o=t[i];o.updateBoundingSphereRadius();const r=e[i].length(),a=o.boundingSphereRadius;r+a>s&&(s=r+a)}this.boundingRadius=s}updateAABB(){const t=this.shapes,e=this.shapeOffsets,n=this.shapeOrientations,s=t.length,i=Wi,o=ji,r=this.quaternion,a=this.aabb,c=Ui;for(let l=0;l!==s;l++){const u=t[l];r.vmult(e[l],i),i.vadd(this.position,i),r.mult(n[l],o),u.calculateWorldAABB(i,o,c.lowerBound,c.upperBound),l===0?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const n=Xi,s=Yi;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(e,n),n.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new d),this.type!==H.DYNAMIC)return;this.sleepState===H.SLEEPING&&this.wakeUp();const n=Ki;e.cross(t,n),this.force.vadd(t,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new d),this.type!==H.DYNAMIC)return;const n=Zi,s=Qi;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyForce(n,s)}applyTorque(t){this.type===H.DYNAMIC&&(this.sleepState===H.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new d),this.type!==H.DYNAMIC)return;this.sleepState===H.SLEEPING&&this.wakeUp();const n=e,s=$i;s.copy(t),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=Ji;n.cross(t,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new d),this.type!==H.DYNAMIC)return;const n=to,s=eo;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyImpulse(n,s)}updateMassProperties(){const t=no;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,n=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Nt.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!n?1/e.x:0,e.y>0&&!n?1/e.y:0,e.z>0&&!n?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const n=new d;return t.vsub(this.position,n),this.angularVelocity.cross(n,e),this.velocity.vadd(e,e),e}integrate(t,e,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===H.DYNAMIC||this.type===H.KINEMATIC)||this.sleepState===H.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,a=this.torque,c=this.quaternion,l=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,f=l*t;s.x+=r.x*f*h.x,s.y+=r.y*f*h.y,s.z+=r.z*f*h.z;const p=u.elements,w=this.angularFactor,m=a.x*w.x,v=a.y*w.y,x=a.z*w.z;i.x+=t*(p[0]*m+p[1]*v+p[2]*x),i.y+=t*(p[3]*m+p[4]*v+p[5]*x),i.z+=t*(p[6]*m+p[7]*v+p[8]*x),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,c.integrate(this.angularVelocity,t,this.angularFactor,c),e&&(n?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}H.idCounter=0;H.COLLIDE_EVENT_NAME="collide";H.DYNAMIC=Kn.DYNAMIC;H.STATIC=Kn.STATIC;H.KINEMATIC=Kn.KINEMATIC;H.AWAKE=Zn.AWAKE;H.SLEEPY=Zn.SLEEPY;H.SLEEPING=Zn.SLEEPING;H.wakeupEvent={type:"wakeup"};H.sleepyEvent={type:"sleepy"};H.sleepEvent={type:"sleep"};const Wi=new d,ji=new bt,Ui=new Ot,Xi=new Zt,Yi=new Zt;new Zt;const Ki=new d,Zi=new d,Qi=new d,$i=new d,Ji=new d,to=new d,eo=new d,no=new d;class so{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!(!(t.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&t.collisionFilterMask)||(t.type&H.STATIC||t.sleepState===H.SLEEPING)&&(e.type&H.STATIC||e.sleepState===H.SLEEPING))}intersectionTest(t,e,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,n,s):this.doBoundingSphereBroadphase(t,e,n,s)}doBoundingSphereBroadphase(t,e,n,s){const i=io;e.position.vsub(t.position,i);const o=(t.boundingRadius+e.boundingRadius)**2;i.lengthSquared()<o&&(n.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,n,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(n.push(t),s.push(e))}makePairsUnique(t,e){const n=oo,s=ro,i=ao,o=t.length;for(let r=0;r!==o;r++)s[r]=t[r],i[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const a=s[r].id,c=i[r].id,l=a<c?`${a},${c}`:`${c},${a}`;n[l]=r,n.keys.push(l)}for(let r=0;r!==n.keys.length;r++){const a=n.keys.pop(),c=n[a];t.push(s[c]),e.push(i[c]),delete n[a]}}setWorld(t){}static boundingSphereCheck(t,e){const n=new d;t.position.vsub(e.position,n);const s=t.shapes[0],i=e.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(t,e,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const io=new d;new d;new bt;new d;const oo={keys:[]},ro=[],ao=[];new d;new d;new d;class Ds extends so{constructor(){super()}collisionPairs(t,e,n){const s=t.bodies,i=s.length;let o,r;for(let a=0;a!==i;a++)for(let c=0;c!==a;c++)o=s[a],r=s[c],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,n)}aabbQuery(t,e,n){n===void 0&&(n=[]);for(let s=0;s<t.bodies.length;s++){const i=t.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(e)&&n.push(i)}return n}}class Ye{constructor(){this.rayFromWorld=new d,this.rayToWorld=new d,this.hitNormalWorld=new d,this.hitPointWorld=new d,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,n,s,i,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let Ns,Os,qs,Gs,_s,Hs,Ws;const Qn={CLOSEST:1,ANY:2,ALL:4};Ns=X.types.SPHERE;Os=X.types.PLANE;qs=X.types.BOX;Gs=X.types.CYLINDER;_s=X.types.CONVEXPOLYHEDRON;Hs=X.types.HEIGHTFIELD;Ws=X.types.TRIMESH;class vt{get[Ns](){return this._intersectSphere}get[Os](){return this._intersectPlane}get[qs](){return this._intersectBox}get[Gs](){return this._intersectConvex}get[_s](){return this._intersectConvex}get[Hs](){return this._intersectHeightfield}get[Ws](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new d),e===void 0&&(e=new d),this.from=t.clone(),this.to=e.clone(),this.direction=new d,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=vt.ANY,this.result=new Ye,this.hasHit=!1,this.callback=n=>{}}intersectWorld(t,e){return this.mode=e.mode||vt.ANY,this.result=e.result||new Ye,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(ys),Pn.length=0,t.broadphase.aabbQuery(t,ys,Pn),this.intersectBodies(Pn),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!t.collisionResponse||!(this.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&this.collisionFilterMask))return;const s=co,i=lo;for(let o=0,r=t.shapes.length;o<r;o++){const a=t.shapes[o];if(!(n&&!a.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],i),t.quaternion.vmult(t.shapeOffsets[o],s),s.vadd(t.position,s),this.intersectShape(a,i,s,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let n=0,s=t.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(t[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,n,s){const i=this.from;if(Ao(i,this.direction,n)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,n,s,t)}_intersectBox(t,e,n,s,i){return this._intersectConvex(t.convexPolyhedronRepresentation,e,n,s,i)}_intersectPlane(t,e,n,s,i){const o=this.from,r=this.to,a=this.direction,c=new d(0,0,1);e.vmult(c,c);const l=new d;o.vsub(n,l);const u=l.dot(c);r.vsub(n,l);const h=l.dot(c);if(u*h>0||o.distanceTo(r)<u)return;const f=c.dot(a);if(Math.abs(f)<this.precision)return;const p=new d,w=new d,m=new d;o.vsub(n,p);const v=-c.dot(p)/f;a.scale(v,w),o.vadd(w,m),this.reportIntersection(c,m,i,s,-1)}getAABB(t){const{lowerBound:e,upperBound:n}=t,s=this.to,i=this.from;e.x=Math.min(s.x,i.x),e.y=Math.min(s.y,i.y),e.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(t,e,n,s,i){t.data,t.elementSize;const o=ho;o.from.copy(this.from),o.to.copy(this.to),at.pointToLocalFrame(n,e,o.from,o.from),at.pointToLocalFrame(n,e,o.to,o.to),o.updateDirection();const r=uo;let a,c,l,u;a=c=0,l=u=t.data.length-1;const h=new Ot;o.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,r,!0),a=Math.max(a,r[0]),c=Math.max(c,r[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,r,!0),l=Math.min(l,r[0]+1),u=Math.min(u,r[1]+1);for(let f=a;f<l;f++)for(let p=c;p<u;p++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(f,p,h),!!h.overlapsRay(o)){if(t.getConvexTrianglePillar(f,p,!1),at.pointToWorldFrame(n,e,t.pillarOffset,nn),this._intersectConvex(t.pillarConvex,e,nn,s,i,ws),this.result.shouldStop)return;t.getConvexTrianglePillar(f,p,!0),at.pointToWorldFrame(n,e,t.pillarOffset,nn),this._intersectConvex(t.pillarConvex,e,nn,s,i,ws)}}}_intersectSphere(t,e,n,s,i){const o=this.from,r=this.to,a=t.radius,c=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,l=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),u=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-a**2,h=l**2-4*c*u,f=po,p=fo;if(!(h<0))if(h===0)o.lerp(r,h,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1);else{const w=(-l-Math.sqrt(h))/(2*c),m=(-l+Math.sqrt(h))/(2*c);if(w>=0&&w<=1&&(o.lerp(r,w,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1)),this.result.shouldStop)return;m>=0&&m<=1&&(o.lerp(r,m,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1))}}_intersectConvex(t,e,n,s,i,o){const r=mo,a=xs,c=o&&o.faceList||null,l=t.faces,u=t.vertices,h=t.faceNormals,f=this.direction,p=this.from,w=this.to,m=p.distanceTo(w),v=c?c.length:l.length,x=this.result;for(let M=0;!x.shouldStop&&M<v;M++){const E=c?c[M]:M,P=l[E],S=h[E],V=e,O=n;a.copy(u[P[0]]),V.vmult(a,a),a.vadd(O,a),a.vsub(p,a),V.vmult(S,r);const K=f.dot(r);if(Math.abs(K)<this.precision)continue;const I=r.dot(a)/K;if(!(I<0)){f.scale(I,Vt),Vt.vadd(p,Vt),Yt.copy(u[P[0]]),V.vmult(Yt,Yt),O.vadd(Yt,Yt);for(let W=1;!x.shouldStop&&W<P.length-1;W++){Jt.copy(u[P[W]]),te.copy(u[P[W+1]]),V.vmult(Jt,Jt),V.vmult(te,te),O.vadd(Jt,Jt),O.vadd(te,te);const _=Vt.distanceTo(p);!(vt.pointInTriangle(Vt,Yt,Jt,te)||vt.pointInTriangle(Vt,Jt,Yt,te))||_>m||this.reportIntersection(r,Vt,i,s,E)}}}}_intersectTrimesh(t,e,n,s,i,o){const r=yo,a=Mo,c=zo,l=xs,u=wo,h=xo,f=go,p=bo,w=vo,m=t.indices;t.vertices;const v=this.from,x=this.to,M=this.direction;c.position.copy(n),c.quaternion.copy(e),at.vectorToLocalFrame(n,e,M,u),at.pointToLocalFrame(n,e,v,h),at.pointToLocalFrame(n,e,x,f),f.x*=t.scale.x,f.y*=t.scale.y,f.z*=t.scale.z,h.x*=t.scale.x,h.y*=t.scale.y,h.z*=t.scale.z,f.vsub(h,u),u.normalize();const E=h.distanceSquared(f);t.tree.rayQuery(this,c,a);for(let P=0,S=a.length;!this.result.shouldStop&&P!==S;P++){const V=a[P];t.getNormal(V,r),t.getVertex(m[V*3],Yt),Yt.vsub(h,l);const O=u.dot(r),K=r.dot(l)/O;if(K<0)continue;u.scale(K,Vt),Vt.vadd(h,Vt),t.getVertex(m[V*3+1],Jt),t.getVertex(m[V*3+2],te);const I=Vt.distanceSquared(h);!(vt.pointInTriangle(Vt,Jt,Yt,te)||vt.pointInTriangle(Vt,Yt,Jt,te))||I>E||(at.vectorToWorldFrame(e,r,w),at.pointToWorldFrame(n,e,Vt,p),this.reportIntersection(w,p,i,s,V))}a.length=0}reportIntersection(t,e,n,s,i){const o=this.from,r=this.to,a=o.distanceTo(e),c=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(c.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case vt.ALL:this.hasHit=!0,c.set(o,r,t,e,n,s,a),c.hasHit=!0,this.callback(c);break;case vt.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a));break;case vt.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a),c.shouldStop=!0;break}}static pointInTriangle(t,e,n,s){s.vsub(e,Ee),n.vsub(e,_e),t.vsub(e,In);const i=Ee.dot(Ee),o=Ee.dot(_e),r=Ee.dot(In),a=_e.dot(_e),c=_e.dot(In);let l,u;return(l=a*r-o*c)>=0&&(u=i*c-o*r)>=0&&l+u<i*a-o*o}}vt.CLOSEST=Qn.CLOSEST;vt.ANY=Qn.ANY;vt.ALL=Qn.ALL;const ys=new Ot,Pn=[],_e=new d,In=new d,co=new d,lo=new bt,Vt=new d,Yt=new d,Jt=new d,te=new d;new d;new Ye;const ws={faceList:[0]},nn=new d,ho=new vt,uo=[],po=new d,fo=new d,mo=new d;new d;new d;const xs=new d,yo=new d,wo=new d,xo=new d,go=new d,vo=new d,bo=new d;new Ot;const Mo=[],zo=new at,Ee=new d,sn=new d;function Ao(y,t,e){e.vsub(y,Ee);const n=Ee.dot(t);return t.scale(n,sn),sn.vadd(y,sn),e.distanceTo(sn)}class Eo{static defaults(t,e){t===void 0&&(t={});for(let n in e)n in t||(t[n]=e[n]);return t}}class gs{constructor(){this.spatial=new d,this.rotational=new d}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class Ze{constructor(t,e,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=Ze.idCounter++,this.minForce=n,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new gs,this.jacobianElementB=new gs,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,n){const s=e,i=t,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(t,e,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*t-s*e-o*n}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return t.spatial.dot(i)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,a=s.angularVelocity;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,a=s.wlambda;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,a=s.torque,c=n.invMassSolve,l=s.invMassSolve;return i.scale(c,vs),r.scale(l,bs),n.invInertiaWorldSolve.vmult(o,Ms),s.invInertiaWorldSolve.vmult(a,zs),t.multiplyVectors(vs,Ms)+e.multiplyVectors(bs,zs)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,a=s.invInertiaWorldSolve;let c=i+o;return r.vmult(t.rotational,on),c+=on.dot(t.rotational),a.vmult(e.rotational,on),c+=on.dot(e.rotational),c}addToWlambda(t){const e=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=So;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*t,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,o),s.wlambda.addScaledVector(t,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Ze.idCounter=0;const vs=new d,bs=new d,Ms=new d,zs=new d,on=new d,So=new d;class Co extends Ze{constructor(t,e,n){n===void 0&&(n=1e6),super(t,e,0,n),this.restitution=0,this.ri=new d,this.rj=new d,this.ni=new d}computeB(t){const e=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,a=Bo,c=To,l=s.velocity,u=s.angularVelocity;s.force,s.torque;const h=i.velocity,f=i.angularVelocity;i.force,i.torque;const p=Po,w=this.jacobianElementA,m=this.jacobianElementB,v=this.ni;o.cross(v,a),r.cross(v,c),v.negate(w.spatial),a.negate(w.rotational),m.spatial.copy(v),m.rotational.copy(c),p.copy(i.position),p.vadd(r,p),p.vsub(s.position,p),p.vsub(o,p);const x=v.dot(p),M=this.restitution+1,E=M*h.dot(v)-M*l.dot(v)+f.dot(c)-u.dot(a),P=this.computeGiMf();return-x*e-E*n-t*P}getImpactVelocityAlongNormal(){const t=Io,e=Fo,n=Ro,s=Lo,i=ko;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,t),this.bj.getVelocityAtWorldPoint(s,e),t.vsub(e,i),this.ni.dot(i)}}const Bo=new d,To=new d,Po=new d,Io=new d,Fo=new d,Ro=new d,Lo=new d,ko=new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;class As extends Ze{constructor(t,e,n){super(t,e,-n,n),this.ri=new d,this.rj=new d,this.t=new d}computeB(t){this.a;const e=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=Vo,o=Do,r=this.t;n.cross(r,i),s.cross(r,o);const a=this.jacobianElementA,c=this.jacobianElementB;r.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(r),c.rotational.copy(o);const l=this.computeGW(),u=this.computeGiMf();return-l*e-t*u}}const Vo=new d,Do=new d;class yn{constructor(t,e,n){n=Eo.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=yn.idCounter++,this.materials=[t,e],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}yn.idCounter=0;class wn{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=wn.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}wn.idCounter=0;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new vt;new d;new d;new d;new d(1,0,0),new d(0,1,0),new d(0,0,1);new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;class xn extends X{constructor(t){if(super({type:X.types.SPHERE}),this.radius=t!==void 0?t:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,e){e===void 0&&(e=new d);const n=2*t*this.radius*this.radius/5;return e.x=n,e.y=n,e.z=n,e}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,e,n,s){const i=this.radius,o=["x","y","z"];for(let r=0;r<o.length;r++){const a=o[r];n[a]=t[a]-i,s[a]=t[a]+i}}}new d;new d;new d;new d;new d;new d;new d;new d;new d;class No extends Le{constructor(t,e,n,s){if(t===void 0&&(t=1),e===void 0&&(e=1),n===void 0&&(n=1),s===void 0&&(s=8),t<0)throw new Error("The cylinder radiusTop cannot be negative.");if(e<0)throw new Error("The cylinder radiusBottom cannot be negative.");const i=s,o=[],r=[],a=[],c=[],l=[],u=Math.cos,h=Math.sin;o.push(new d(-e*h(0),-n*.5,e*u(0))),c.push(0),o.push(new d(-t*h(0),n*.5,t*u(0))),l.push(1);for(let p=0;p<i;p++){const w=2*Math.PI/i*(p+1),m=2*Math.PI/i*(p+.5);p<i-1?(o.push(new d(-e*h(w),-n*.5,e*u(w))),c.push(2*p+2),o.push(new d(-t*h(w),n*.5,t*u(w))),l.push(2*p+3),a.push([2*p,2*p+1,2*p+3,2*p+2])):a.push([2*p,2*p+1,1,0]),(i%2===1||p<i/2)&&r.push(new d(-h(m),0,u(m)))}a.push(c),r.push(new d(0,1,0));const f=[];for(let p=0;p<l.length;p++)f.push(l[l.length-p-1]);a.push(f),super({vertices:o,faces:a,axes:r}),this.type=X.types.CYLINDER,this.radiusTop=t,this.radiusBottom=e,this.height=n,this.numSegments=s}}class Oo extends X{constructor(){super({type:X.types.PLANE}),this.worldNormal=new d,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){const e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return e===void 0&&(e=new d),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,n,s){oe.set(0,0,1),e.vmult(oe,oe);const i=Number.MAX_VALUE;n.set(-i,-i,-i),s.set(i,i,i),oe.x===1?s.x=t.x:oe.x===-1&&(n.x=t.x),oe.y===1?s.y=t.y:oe.y===-1&&(n.y=t.y),oe.z===1?s.z=t.z:oe.z===-1&&(n.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const oe=new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new d;new Ot;new d;new Ot;new d;new d;new d;new d;new d;new d;new d;new Ot;new d;new at;new Ot;class qo{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,n=e.indexOf(t);n!==-1&&e.splice(n,1)}removeAllEquations(){this.equations.length=0}}class Go extends qo{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=e.bodies,c=a.length,l=t;let u,h,f,p,w,m;if(r!==0)for(let E=0;E!==c;E++)a[E].updateSolveMassProperties();const v=Ho,x=Wo,M=_o;v.length=r,x.length=r,M.length=r;for(let E=0;E!==r;E++){const P=o[E];M[E]=0,x[E]=P.computeB(l),v[E]=1/P.computeC()}if(r!==0){for(let S=0;S!==c;S++){const V=a[S],O=V.vlambda,K=V.wlambda;O.set(0,0,0),K.set(0,0,0)}for(n=0;n!==s;n++){p=0;for(let S=0;S!==r;S++){const V=o[S];u=x[S],h=v[S],m=M[S],w=V.computeGWlambda(),f=h*(u-w-V.eps*m),m+f<V.minForce?f=V.minForce-m:m+f>V.maxForce&&(f=V.maxForce-m),M[S]+=f,p+=f>0?f:-f,V.addToWlambda(f)}if(p*p<i)break}for(let S=0;S!==c;S++){const V=a[S],O=V.velocity,K=V.angularVelocity;V.vlambda.vmul(V.linearFactor,V.vlambda),O.vadd(V.vlambda,O),V.wlambda.vmul(V.angularFactor,V.wlambda),K.vadd(V.wlambda,K)}let E=o.length;const P=1/l;for(;E--;)o[E].multiplier=M[E]*P}return n}}const _o=[],Ho=[],Wo=[];class jo{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class Uo extends jo{constructor(){super(...arguments),this.type=d}constructObject(){return new d}}const ut={sphereSphere:X.types.SPHERE,spherePlane:X.types.SPHERE|X.types.PLANE,boxBox:X.types.BOX|X.types.BOX,sphereBox:X.types.SPHERE|X.types.BOX,planeBox:X.types.PLANE|X.types.BOX,convexConvex:X.types.CONVEXPOLYHEDRON,sphereConvex:X.types.SPHERE|X.types.CONVEXPOLYHEDRON,planeConvex:X.types.PLANE|X.types.CONVEXPOLYHEDRON,boxConvex:X.types.BOX|X.types.CONVEXPOLYHEDRON,sphereHeightfield:X.types.SPHERE|X.types.HEIGHTFIELD,boxHeightfield:X.types.BOX|X.types.HEIGHTFIELD,convexHeightfield:X.types.CONVEXPOLYHEDRON|X.types.HEIGHTFIELD,sphereParticle:X.types.PARTICLE|X.types.SPHERE,planeParticle:X.types.PLANE|X.types.PARTICLE,boxParticle:X.types.BOX|X.types.PARTICLE,convexParticle:X.types.PARTICLE|X.types.CONVEXPOLYHEDRON,cylinderCylinder:X.types.CYLINDER,sphereCylinder:X.types.SPHERE|X.types.CYLINDER,planeCylinder:X.types.PLANE|X.types.CYLINDER,boxCylinder:X.types.BOX|X.types.CYLINDER,convexCylinder:X.types.CONVEXPOLYHEDRON|X.types.CYLINDER,heightfieldCylinder:X.types.HEIGHTFIELD|X.types.CYLINDER,particleCylinder:X.types.PARTICLE|X.types.CYLINDER,sphereTrimesh:X.types.SPHERE|X.types.TRIMESH,planeTrimesh:X.types.PLANE|X.types.TRIMESH};class Xo{get[ut.sphereSphere](){return this.sphereSphere}get[ut.spherePlane](){return this.spherePlane}get[ut.boxBox](){return this.boxBox}get[ut.sphereBox](){return this.sphereBox}get[ut.planeBox](){return this.planeBox}get[ut.convexConvex](){return this.convexConvex}get[ut.sphereConvex](){return this.sphereConvex}get[ut.planeConvex](){return this.planeConvex}get[ut.boxConvex](){return this.boxConvex}get[ut.sphereHeightfield](){return this.sphereHeightfield}get[ut.boxHeightfield](){return this.boxHeightfield}get[ut.convexHeightfield](){return this.convexHeightfield}get[ut.sphereParticle](){return this.sphereParticle}get[ut.planeParticle](){return this.planeParticle}get[ut.boxParticle](){return this.boxParticle}get[ut.convexParticle](){return this.convexParticle}get[ut.cylinderCylinder](){return this.convexConvex}get[ut.sphereCylinder](){return this.sphereConvex}get[ut.planeCylinder](){return this.planeConvex}get[ut.boxCylinder](){return this.boxConvex}get[ut.convexCylinder](){return this.convexConvex}get[ut.heightfieldCylinder](){return this.heightfieldCylinder}get[ut.particleCylinder](){return this.particleCylinder}get[ut.sphereTrimesh](){return this.sphereTrimesh}get[ut.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Uo,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new Co(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&n.collisionResponse&&s.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=n.material||t.material,l=s.material||e.material;return c&&l&&c.restitution>=0&&l.restitution>=0&&(r.restitution=c.restitution*l.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){const n=t.bi,s=t.bj,i=t.si,o=t.sj,r=this.world,a=this.currentContactMaterial;let c=a.friction;const l=i.material||n.material,u=o.material||s.material;if(l&&u&&l.friction>=0&&u.friction>=0&&(c=l.friction*u.friction),c>0){const h=c*(r.frictionGravity||r.gravity).length();let f=n.invMass+s.invMass;f>0&&(f=1/f);const p=this.frictionEquationPool,w=p.length?p.pop():new As(n,s,h*f),m=p.length?p.pop():new As(n,s,h*f);return w.bi=m.bi=n,w.bj=m.bj=s,w.minForce=m.minForce=-h*f,w.maxForce=m.maxForce=h*f,w.ri.copy(t.ri),w.rj.copy(t.rj),m.ri.copy(t.ri),m.rj.copy(t.rj),t.ni.tangents(w.t,m.t),w.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),m.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),w.enabled=m.enabled=t.enabled,e.push(w,m),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];Ae.setZero(),Ie.setZero(),Fe.setZero();const i=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==i?(Ae.vadd(e.ni,Ae),Ie.vadd(e.ri,Ie),Fe.vadd(e.rj,Fe)):(Ae.vsub(e.ni,Ae),Ie.vadd(e.rj,Ie),Fe.vadd(e.ri,Fe));const o=1/t;Ie.scale(o,n.ri),Fe.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),Ae.normalize(),Ae.tangents(n.t,s.t)}getContacts(t,e,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const a=Zo,c=Qo,l=Yo,u=Ko;for(let h=0,f=t.length;h!==f;h++){const p=t[h],w=e[h];let m=null;p.material&&w.material&&(m=n.getContactMaterial(p.material,w.material)||null);const v=p.type&H.KINEMATIC&&w.type&H.STATIC||p.type&H.STATIC&&w.type&H.KINEMATIC||p.type&H.KINEMATIC&&w.type&H.KINEMATIC;for(let x=0;x<p.shapes.length;x++){p.quaternion.mult(p.shapeOrientations[x],a),p.quaternion.vmult(p.shapeOffsets[x],l),l.vadd(p.position,l);const M=p.shapes[x];for(let E=0;E<w.shapes.length;E++){w.quaternion.mult(w.shapeOrientations[E],c),w.quaternion.vmult(w.shapeOffsets[E],u),u.vadd(w.position,u);const P=w.shapes[E];if(!(M.collisionFilterMask&P.collisionFilterGroup&&P.collisionFilterMask&M.collisionFilterGroup)||l.distanceTo(u)>M.boundingSphereRadius+P.boundingSphereRadius)continue;let S=null;M.material&&P.material&&(S=n.getContactMaterial(M.material,P.material)||null),this.currentContactMaterial=S||m||n.defaultContactMaterial;const V=M.type|P.type,O=this[V];if(O){let K=!1;M.type<P.type?K=O.call(this,M,P,l,u,a,c,p,w,M,P,v):K=O.call(this,P,M,u,l,c,a,w,p,M,P,v),K&&v&&(n.shapeOverlapKeeper.set(M.id,P.id),n.bodyOverlapKeeper.set(p.id,w.id))}}}}}sphereSphere(t,e,n,s,i,o,r,a,c,l,u){if(u)return n.distanceSquared(s)<(t.radius+e.radius)**2;const h=this.createContactEquation(r,a,t,e,c,l);s.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(t.radius,h.ri),h.rj.scale(-e.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(r.position,h.ri),h.rj.vadd(s,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(t,e,n,s,i,o,r,a,c,l,u){const h=this.createContactEquation(r,a,t,e,c,l);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(t.radius,h.ri),n.vsub(s,rn),h.ni.scale(h.ni.dot(rn),Es),rn.vsub(Es,h.rj),-rn.dot(h.ni)<=t.radius){if(u)return!0;const f=h.ri,p=h.rj;f.vadd(n,f),f.vsub(r.position,f),p.vadd(s,p),p.vsub(a.position,p),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(t,e,n,s,i,o,r,a,c,l,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,u)}sphereBox(t,e,n,s,i,o,r,a,c,l,u){const h=this.v3pool,f=zr;n.vsub(s,an),e.getSideNormals(f,o);const p=t.radius;let w=!1;const m=Er,v=Sr,x=Cr;let M=null,E=0,P=0,S=0,V=null;for(let T=0,it=f.length;T!==it&&w===!1;T++){const nt=vr;nt.copy(f[T]);const et=nt.length();nt.normalize();const pt=an.dot(nt);if(pt<et+p&&pt>0){const wt=br,$=Mr;wt.copy(f[(T+1)%3]),$.copy(f[(T+2)%3]);const At=wt.length(),qt=$.length();wt.normalize(),$.normalize();const se=an.dot(wt),jt=an.dot($);if(se<At&&se>-At&&jt<qt&&jt>-qt){const Qt=Math.abs(pt-et-p);if((V===null||Qt<V)&&(V=Qt,P=se,S=jt,M=et,m.copy(nt),v.copy(wt),x.copy($),E++,u))return!0}}}if(E){w=!0;const T=this.createContactEquation(r,a,t,e,c,l);m.scale(-p,T.ri),T.ni.copy(m),T.ni.negate(T.ni),m.scale(M,m),v.scale(P,v),m.vadd(v,m),x.scale(S,x),m.vadd(x,T.rj),T.ri.vadd(n,T.ri),T.ri.vsub(r.position,T.ri),T.rj.vadd(s,T.rj),T.rj.vsub(a.position,T.rj),this.result.push(T),this.createFrictionEquationsFromContact(T,this.frictionResult)}let O=h.get();const K=Ar;for(let T=0;T!==2&&!w;T++)for(let it=0;it!==2&&!w;it++)for(let nt=0;nt!==2&&!w;nt++)if(O.set(0,0,0),T?O.vadd(f[0],O):O.vsub(f[0],O),it?O.vadd(f[1],O):O.vsub(f[1],O),nt?O.vadd(f[2],O):O.vsub(f[2],O),s.vadd(O,K),K.vsub(n,K),K.lengthSquared()<p*p){if(u)return!0;w=!0;const et=this.createContactEquation(r,a,t,e,c,l);et.ri.copy(K),et.ri.normalize(),et.ni.copy(et.ri),et.ri.scale(p,et.ri),et.rj.copy(O),et.ri.vadd(n,et.ri),et.ri.vsub(r.position,et.ri),et.rj.vadd(s,et.rj),et.rj.vsub(a.position,et.rj),this.result.push(et),this.createFrictionEquationsFromContact(et,this.frictionResult)}h.release(O),O=null;const I=h.get(),W=h.get(),_=h.get(),z=h.get(),R=h.get(),k=f.length;for(let T=0;T!==k&&!w;T++)for(let it=0;it!==k&&!w;it++)if(T%3!==it%3){f[it].cross(f[T],I),I.normalize(),f[T].vadd(f[it],W),_.copy(n),_.vsub(W,_),_.vsub(s,_);const nt=_.dot(I);I.scale(nt,z);let et=0;for(;et===T%3||et===it%3;)et++;R.copy(n),R.vsub(z,R),R.vsub(W,R),R.vsub(s,R);const pt=Math.abs(nt),wt=R.length();if(pt<f[et].length()&&wt<p){if(u)return!0;w=!0;const $=this.createContactEquation(r,a,t,e,c,l);W.vadd(z,$.rj),$.rj.copy($.rj),R.negate($.ni),$.ni.normalize(),$.ri.copy($.rj),$.ri.vadd(s,$.ri),$.ri.vsub(n,$.ri),$.ri.normalize(),$.ri.scale(p,$.ri),$.ri.vadd(n,$.ri),$.ri.vsub(r.position,$.ri),$.rj.vadd(s,$.rj),$.rj.vsub(a.position,$.rj),this.result.push($),this.createFrictionEquationsFromContact($,this.frictionResult)}}h.release(I,W,_,z,R)}planeBox(t,e,n,s,i,o,r,a,c,l,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,u)}convexConvex(t,e,n,s,i,o,r,a,c,l,u,h,f){const p=_r;if(!(n.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,n,i,s,o,p,h,f)){const w=[],m=Hr;t.clipAgainstHull(n,i,e,s,o,p,-100,100,w);let v=0;for(let x=0;x!==w.length;x++){if(u)return!0;const M=this.createContactEquation(r,a,t,e,c,l),E=M.ri,P=M.rj;p.negate(M.ni),w[x].normal.negate(m),m.scale(w[x].depth,m),w[x].point.vadd(m,E),P.copy(w[x].point),E.vsub(n,E),P.vsub(s,P),E.vadd(n,E),E.vsub(r.position,E),P.vadd(s,P),P.vsub(a.position,P),this.result.push(M),v++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(M,this.frictionResult)}this.enableFrictionReduction&&v&&this.createFrictionFromAverage(v)}}sphereConvex(t,e,n,s,i,o,r,a,c,l,u){const h=this.v3pool;n.vsub(s,Br);const f=e.faceNormals,p=e.faces,w=e.vertices,m=t.radius;let v=!1;for(let x=0;x!==w.length;x++){const M=w[x],E=Fr;o.vmult(M,E),s.vadd(E,E);const P=Ir;if(E.vsub(n,P),P.lengthSquared()<m*m){if(u)return!0;v=!0;const S=this.createContactEquation(r,a,t,e,c,l);S.ri.copy(P),S.ri.normalize(),S.ni.copy(S.ri),S.ri.scale(m,S.ri),E.vsub(s,S.rj),S.ri.vadd(n,S.ri),S.ri.vsub(r.position,S.ri),S.rj.vadd(s,S.rj),S.rj.vsub(a.position,S.rj),this.result.push(S),this.createFrictionEquationsFromContact(S,this.frictionResult);return}}for(let x=0,M=p.length;x!==M&&v===!1;x++){const E=f[x],P=p[x],S=Rr;o.vmult(E,S);const V=Lr;o.vmult(w[P[0]],V),V.vadd(s,V);const O=kr;S.scale(-m,O),n.vadd(O,O);const K=Vr;O.vsub(V,K);const I=K.dot(S),W=Dr;if(n.vsub(V,W),I<0&&W.dot(S)>0){const _=[];for(let z=0,R=P.length;z!==R;z++){const k=h.get();o.vmult(w[P[z]],k),s.vadd(k,k),_.push(k)}if(gr(_,S,n)){if(u)return!0;v=!0;const z=this.createContactEquation(r,a,t,e,c,l);S.scale(-m,z.ri),S.negate(z.ni);const R=h.get();S.scale(-I,R);const k=h.get();S.scale(-m,k),n.vsub(s,z.rj),z.rj.vadd(k,z.rj),z.rj.vadd(R,z.rj),z.rj.vadd(s,z.rj),z.rj.vsub(a.position,z.rj),z.ri.vadd(n,z.ri),z.ri.vsub(r.position,z.ri),h.release(R),h.release(k),this.result.push(z),this.createFrictionEquationsFromContact(z,this.frictionResult);for(let T=0,it=_.length;T!==it;T++)h.release(_[T]);return}else for(let z=0;z!==P.length;z++){const R=h.get(),k=h.get();o.vmult(w[P[(z+1)%P.length]],R),o.vmult(w[P[(z+2)%P.length]],k),s.vadd(R,R),s.vadd(k,k);const T=Tr;k.vsub(R,T);const it=Pr;T.unit(it);const nt=h.get(),et=h.get();n.vsub(R,et);const pt=et.dot(it);it.scale(pt,nt),nt.vadd(R,nt);const wt=h.get();if(nt.vsub(n,wt),pt>0&&pt*pt<T.lengthSquared()&&wt.lengthSquared()<m*m){if(u)return!0;const $=this.createContactEquation(r,a,t,e,c,l);nt.vsub(s,$.rj),nt.vsub(n,$.ni),$.ni.normalize(),$.ni.scale(m,$.ri),$.rj.vadd(s,$.rj),$.rj.vsub(a.position,$.rj),$.ri.vadd(n,$.ri),$.ri.vsub(r.position,$.ri),this.result.push($),this.createFrictionEquationsFromContact($,this.frictionResult);for(let At=0,qt=_.length;At!==qt;At++)h.release(_[At]);h.release(R),h.release(k),h.release(nt),h.release(wt),h.release(et);return}h.release(R),h.release(k),h.release(nt),h.release(wt),h.release(et)}for(let z=0,R=_.length;z!==R;z++)h.release(_[z])}}}planeConvex(t,e,n,s,i,o,r,a,c,l,u){const h=Nr,f=Or;f.set(0,0,1),i.vmult(f,f);let p=0;const w=qr;for(let m=0;m!==e.vertices.length;m++)if(h.copy(e.vertices[m]),o.vmult(h,h),s.vadd(h,h),h.vsub(n,w),f.dot(w)<=0){if(u)return!0;const x=this.createContactEquation(r,a,t,e,c,l),M=Gr;f.scale(f.dot(w),M),h.vsub(M,M),M.vsub(n,x.ri),x.ni.copy(f),h.vsub(s,x.rj),x.ri.vadd(n,x.ri),x.ri.vsub(r.position,x.ri),x.rj.vadd(s,x.rj),x.rj.vsub(a.position,x.rj),this.result.push(x),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(x,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(t,e,n,s,i,o,r,a,c,l,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,u)}sphereHeightfield(t,e,n,s,i,o,r,a,c,l,u){const h=e.data,f=t.radius,p=e.elementSize,w=ea,m=ta;at.pointToLocalFrame(s,o,n,m);let v=Math.floor((m.x-f)/p)-1,x=Math.ceil((m.x+f)/p)+1,M=Math.floor((m.y-f)/p)-1,E=Math.ceil((m.y+f)/p)+1;if(x<0||E<0||v>h.length||M>h[0].length)return;v<0&&(v=0),x<0&&(x=0),M<0&&(M=0),E<0&&(E=0),v>=h.length&&(v=h.length-1),x>=h.length&&(x=h.length-1),E>=h[0].length&&(E=h[0].length-1),M>=h[0].length&&(M=h[0].length-1);const P=[];e.getRectMinMax(v,M,x,E,P);const S=P[0],V=P[1];if(m.z-f>V||m.z+f<S)return;const O=this.result;for(let K=v;K<x;K++)for(let I=M;I<E;I++){const W=O.length;let _=!1;if(e.getConvexTrianglePillar(K,I,!1),at.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,n,w,i,o,r,a,t,e,u)),u&&_||(e.getConvexTrianglePillar(K,I,!0),at.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,n,w,i,o,r,a,t,e,u)),u&&_))return!0;if(O.length-W>2)return}}boxHeightfield(t,e,n,s,i,o,r,a,c,l,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,u)}convexHeightfield(t,e,n,s,i,o,r,a,c,l,u){const h=e.data,f=e.elementSize,p=t.boundingSphereRadius,w=$r,m=Jr,v=Qr;at.pointToLocalFrame(s,o,n,v);let x=Math.floor((v.x-p)/f)-1,M=Math.ceil((v.x+p)/f)+1,E=Math.floor((v.y-p)/f)-1,P=Math.ceil((v.y+p)/f)+1;if(M<0||P<0||x>h.length||E>h[0].length)return;x<0&&(x=0),M<0&&(M=0),E<0&&(E=0),P<0&&(P=0),x>=h.length&&(x=h.length-1),M>=h.length&&(M=h.length-1),P>=h[0].length&&(P=h[0].length-1),E>=h[0].length&&(E=h[0].length-1);const S=[];e.getRectMinMax(x,E,M,P,S);const V=S[0],O=S[1];if(!(v.z-p>O||v.z+p<V))for(let K=x;K<M;K++)for(let I=E;I<P;I++){let W=!1;if(e.getConvexTrianglePillar(K,I,!1),at.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(W=this.convexConvex(t,e.pillarConvex,n,w,i,o,r,a,null,null,u,m,null)),u&&W||(e.getConvexTrianglePillar(K,I,!0),at.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(W=this.convexConvex(t,e.pillarConvex,n,w,i,o,r,a,null,null,u,m,null)),u&&W))return!0}}sphereParticle(t,e,n,s,i,o,r,a,c,l,u){const h=Xr;if(h.set(0,0,1),s.vsub(n,h),h.lengthSquared()<=t.radius*t.radius){if(u)return!0;const p=this.createContactEquation(a,r,e,t,c,l);h.normalize(),p.rj.copy(h),p.rj.scale(t.radius,p.rj),p.ni.copy(h),p.ni.negate(p.ni),p.ri.set(0,0,0),this.result.push(p),this.createFrictionEquationsFromContact(p,this.frictionResult)}}planeParticle(t,e,n,s,i,o,r,a,c,l,u){const h=Wr;h.set(0,0,1),r.quaternion.vmult(h,h);const f=jr;if(s.vsub(r.position,f),h.dot(f)<=0){if(u)return!0;const w=this.createContactEquation(a,r,e,t,c,l);w.ni.copy(h),w.ni.negate(w.ni),w.ri.set(0,0,0);const m=Ur;h.scale(h.dot(s),m),s.vsub(m,m),w.rj.copy(m),this.result.push(w),this.createFrictionEquationsFromContact(w,this.frictionResult)}}boxParticle(t,e,n,s,i,o,r,a,c,l,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,u)}convexParticle(t,e,n,s,i,o,r,a,c,l,u){let h=-1;const f=Kr,p=Zr;let w=null;const m=Yr;if(m.copy(s),m.vsub(n,m),i.conjugate(Ss),Ss.vmult(m,m),t.pointIsInside(m)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(n,i),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(i);for(let v=0,x=t.faces.length;v!==x;v++){const M=[t.worldVertices[t.faces[v][0]]],E=t.worldFaceNormals[v];s.vsub(M[0],Cs);const P=-E.dot(Cs);if(w===null||Math.abs(P)<Math.abs(w)){if(u)return!0;w=P,h=v,f.copy(E)}}if(h!==-1){const v=this.createContactEquation(a,r,e,t,c,l);f.scale(w,p),p.vadd(s,p),p.vsub(n,p),v.rj.copy(p),f.negate(v.ni),v.ri.set(0,0,0);const x=v.ri,M=v.rj;x.vadd(s,x),x.vsub(a.position,x),M.vadd(n,M),M.vsub(r.position,M),this.result.push(v),this.createFrictionEquationsFromContact(v,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,n,s,i,o,r,a,c,l,u){return this.convexHeightfield(e,t,s,n,o,i,a,r,c,l,u)}particleCylinder(t,e,n,s,i,o,r,a,c,l,u){return this.convexParticle(e,t,s,n,o,i,a,r,c,l,u)}sphereTrimesh(t,e,n,s,i,o,r,a,c,l,u){const h=or,f=rr,p=ar,w=cr,m=lr,v=hr,x=fr,M=ir,E=nr,P=mr;at.pointToLocalFrame(s,o,n,m);const S=t.radius;x.lowerBound.set(m.x-S,m.y-S,m.z-S),x.upperBound.set(m.x+S,m.y+S,m.z+S),e.getTrianglesInAABB(x,P);const V=sr,O=t.radius*t.radius;for(let z=0;z<P.length;z++)for(let R=0;R<3;R++)if(e.getVertex(e.indices[P[z]*3+R],V),V.vsub(m,E),E.lengthSquared()<=O){if(M.copy(V),at.pointToWorldFrame(s,o,M,V),V.vsub(n,E),u)return!0;let k=this.createContactEquation(r,a,t,e,c,l);k.ni.copy(E),k.ni.normalize(),k.ri.copy(k.ni),k.ri.scale(t.radius,k.ri),k.ri.vadd(n,k.ri),k.ri.vsub(r.position,k.ri),k.rj.copy(V),k.rj.vsub(a.position,k.rj),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult)}for(let z=0;z<P.length;z++)for(let R=0;R<3;R++){e.getVertex(e.indices[P[z]*3+R],h),e.getVertex(e.indices[P[z]*3+(R+1)%3],f),f.vsub(h,p),m.vsub(f,v);const k=v.dot(p);m.vsub(h,v);let T=v.dot(p);if(T>0&&k<0&&(m.vsub(h,v),w.copy(p),w.normalize(),T=v.dot(w),w.scale(T,v),v.vadd(h,v),v.distanceTo(m)<t.radius)){if(u)return!0;const nt=this.createContactEquation(r,a,t,e,c,l);v.vsub(m,nt.ni),nt.ni.normalize(),nt.ni.scale(t.radius,nt.ri),nt.ri.vadd(n,nt.ri),nt.ri.vsub(r.position,nt.ri),at.pointToWorldFrame(s,o,v,v),v.vsub(a.position,nt.rj),at.vectorToWorldFrame(o,nt.ni,nt.ni),at.vectorToWorldFrame(o,nt.ri,nt.ri),this.result.push(nt),this.createFrictionEquationsFromContact(nt,this.frictionResult)}}const K=ur,I=dr,W=pr,_=er;for(let z=0,R=P.length;z!==R;z++){e.getTriangleVertices(P[z],K,I,W),e.getNormal(P[z],_),m.vsub(K,v);let k=v.dot(_);if(_.scale(k,v),m.vsub(v,v),k=v.distanceTo(m),vt.pointInTriangle(v,K,I,W)&&k<t.radius){if(u)return!0;let T=this.createContactEquation(r,a,t,e,c,l);v.vsub(m,T.ni),T.ni.normalize(),T.ni.scale(t.radius,T.ri),T.ri.vadd(n,T.ri),T.ri.vsub(r.position,T.ri),at.pointToWorldFrame(s,o,v,v),v.vsub(a.position,T.rj),at.vectorToWorldFrame(o,T.ni,T.ni),at.vectorToWorldFrame(o,T.ri,T.ri),this.result.push(T),this.createFrictionEquationsFromContact(T,this.frictionResult)}}P.length=0}planeTrimesh(t,e,n,s,i,o,r,a,c,l,u){const h=new d,f=$o;f.set(0,0,1),i.vmult(f,f);for(let p=0;p<e.vertices.length/3;p++){e.getVertex(p,h);const w=new d;w.copy(h),at.pointToWorldFrame(s,o,w,h);const m=Jo;if(h.vsub(n,m),f.dot(m)<=0){if(u)return!0;const x=this.createContactEquation(r,a,t,e,c,l);x.ni.copy(f);const M=tr;f.scale(m.dot(f),M),h.vsub(M,M),x.ri.copy(M),x.ri.vsub(r.position,x.ri),x.rj.copy(h),x.rj.vsub(a.position,x.rj),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}}}}const Ae=new d,Ie=new d,Fe=new d,Yo=new d,Ko=new d,Zo=new bt,Qo=new bt,$o=new d,Jo=new d,tr=new d,er=new d,nr=new d;new d;const sr=new d,ir=new d,or=new d,rr=new d,ar=new d,cr=new d,lr=new d,hr=new d,ur=new d,dr=new d,pr=new d,fr=new Ot,mr=[],rn=new d,Es=new d,yr=new d,wr=new d,xr=new d;function gr(y,t,e){let n=null;const s=y.length;for(let i=0;i!==s;i++){const o=y[i],r=yr;y[(i+1)%s].vsub(o,r);const a=wr;r.cross(t,a);const c=xr;e.vsub(o,c);const l=a.dot(c);if(n===null||l>0&&n===!0||l<=0&&n===!1){n===null&&(n=l>0);continue}else return!1}return!0}const an=new d,vr=new d,br=new d,Mr=new d,zr=[new d,new d,new d,new d,new d,new d],Ar=new d,Er=new d,Sr=new d,Cr=new d,Br=new d,Tr=new d,Pr=new d,Ir=new d,Fr=new d,Rr=new d,Lr=new d,kr=new d,Vr=new d,Dr=new d;new d;new d;const Nr=new d,Or=new d,qr=new d,Gr=new d,_r=new d,Hr=new d,Wr=new d,jr=new d,Ur=new d,Xr=new d,Ss=new bt,Yr=new d;new d;const Kr=new d,Cs=new d,Zr=new d,Qr=new d,$r=new d,Jr=[0],ta=new d,ea=new d;class Bs{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const n=e;e=t,t=n}return t<<16|e}set(t,e){const n=this.getKey(t,e),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let a=0;a<i;a++){let c=!1;const l=n[a];for(;l>s[r];)r++;c=l===s[r],c||Ts(t,l)}r=0;for(let a=0;a<o;a++){let c=!1;const l=s[a];for(;l>n[r];)r++;c=n[r]===l,c||Ts(e,l)}}}function Ts(y,t){y.push((t&4294901760)>>16,t&65535)}const Fn=(y,t)=>y<t?`${y}-${t}`:`${t}-${y}`;class na{constructor(){this.data={keys:[]}}get(t,e){const n=Fn(t,e);return this.data[n]}set(t,e,n){const s=Fn(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=n}delete(t,e){const n=Fn(t,e),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const n=e.pop();delete t[n]}}}class sa extends Vs{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new d,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new d,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new Ds,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new Go,this.constraints=[],this.narrowphase=new Xo(this),this.collisionMatrix=new fs,this.collisionMatrixPrevious=new fs,this.bodyOverlapKeeper=new Bs,this.shapeOverlapKeeper=new Bs,this.contactmaterials=[],this.contactMaterialTable=new na,this.defaultMaterial=new wn("default"),this.defaultContactMaterial=new yn(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,n){n instanceof Ye?this.raycastClosest(t,e,{skipBackfaces:!0},n):this.raycastAll(t,e,{skipBackfaces:!0},n)}raycastAll(t,e,n,s){return n===void 0&&(n={}),n.mode=vt.ALL,n.from=t,n.to=e,n.callback=s,Rn.intersectWorld(this,n)}raycastAny(t,e,n,s){return n===void 0&&(n={}),n.mode=vt.ANY,n.from=t,n.to=e,n.result=s,Rn.intersectWorld(this,n)}raycastClosest(t,e,n,s){return n===void 0&&(n={}),n.mode=vt.CLOSEST,n.from=t,n.to=e,n.result=s,Rn.intersectWorld(this,n)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof H&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,n=this.bodies,s=n.indexOf(t);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const n=zt.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const s=n-this.lastCallTime;this.step(t,s,e)}this.lastCallTime=n}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const s=zt.now();let i=0;for(;this.accumulator>=t&&i<n&&(this.internalStep(t),this.accumulator-=t,i++,!(zt.now()-s>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,n=ca,s=la,i=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,c=this.doProfiling,l=this.profile,u=H.DYNAMIC;let h=-1/0;const f=this.constraints,p=aa;a.length();const w=a.x,m=a.y,v=a.z;let x=0;for(c&&(h=zt.now()),x=0;x!==i;x++){const z=o[x];if(z.type===u){const R=z.force,k=z.mass;R.x+=k*w,R.y+=k*m,R.z+=k*v}}for(let z=0,R=this.subsystems.length;z!==R;z++)this.subsystems[z].update();c&&(h=zt.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),c&&(l.broadphase=zt.now()-h);let M=f.length;for(x=0;x!==M;x++){const z=f[x];if(!z.collideConnected)for(let R=n.length-1;R>=0;R-=1)(z.bodyA===n[R]&&z.bodyB===s[R]||z.bodyB===n[R]&&z.bodyA===s[R])&&(n.splice(R,1),s.splice(R,1))}this.collisionMatrixTick(),c&&(h=zt.now());const E=ra,P=e.length;for(x=0;x!==P;x++)E.push(e[x]);e.length=0;const S=this.frictionEquations.length;for(x=0;x!==S;x++)p.push(this.frictionEquations[x]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,e,E,this.frictionEquations,p),c&&(l.narrowphase=zt.now()-h),c&&(h=zt.now()),x=0;x<this.frictionEquations.length;x++)r.addEquation(this.frictionEquations[x]);const V=e.length;for(let z=0;z!==V;z++){const R=e[z],k=R.bi,T=R.bj,it=R.si,nt=R.sj;let et;if(k.material&&T.material?et=this.getContactMaterial(k.material,T.material)||this.defaultContactMaterial:et=this.defaultContactMaterial,et.friction,k.material&&T.material&&(k.material.friction>=0&&T.material.friction>=0&&k.material.friction*T.material.friction,k.material.restitution>=0&&T.material.restitution>=0&&(R.restitution=k.material.restitution*T.material.restitution)),r.addEquation(R),k.allowSleep&&k.type===H.DYNAMIC&&k.sleepState===H.SLEEPING&&T.sleepState===H.AWAKE&&T.type!==H.STATIC){const pt=T.velocity.lengthSquared()+T.angularVelocity.lengthSquared(),wt=T.sleepSpeedLimit**2;pt>=wt*2&&(k.wakeUpAfterNarrowphase=!0)}if(T.allowSleep&&T.type===H.DYNAMIC&&T.sleepState===H.SLEEPING&&k.sleepState===H.AWAKE&&k.type!==H.STATIC){const pt=k.velocity.lengthSquared()+k.angularVelocity.lengthSquared(),wt=k.sleepSpeedLimit**2;pt>=wt*2&&(T.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(k,T,!0),this.collisionMatrixPrevious.get(k,T)||(He.body=T,He.contact=R,k.dispatchEvent(He),He.body=k,T.dispatchEvent(He)),this.bodyOverlapKeeper.set(k.id,T.id),this.shapeOverlapKeeper.set(it.id,nt.id)}for(this.emitContactEvents(),c&&(l.makeContactConstraints=zt.now()-h,h=zt.now()),x=0;x!==i;x++){const z=o[x];z.wakeUpAfterNarrowphase&&(z.wakeUp(),z.wakeUpAfterNarrowphase=!1)}for(M=f.length,x=0;x!==M;x++){const z=f[x];z.update();for(let R=0,k=z.equations.length;R!==k;R++){const T=z.equations[R];r.addEquation(T)}}r.solve(t,this),c&&(l.solve=zt.now()-h),r.removeAllEquations();const O=Math.pow;for(x=0;x!==i;x++){const z=o[x];if(z.type&u){const R=O(1-z.linearDamping,t),k=z.velocity;k.scale(R,k);const T=z.angularVelocity;if(T){const it=O(1-z.angularDamping,t);T.scale(it,T)}}}this.dispatchEvent(oa),c&&(h=zt.now());const I=this.stepnumber%(this.quatNormalizeSkip+1)===0,W=this.quatNormalizeFast;for(x=0;x!==i;x++)o[x].integrate(t,I,W);this.clearForces(),this.broadphase.dirty=!0,c&&(l.integrate=zt.now()-h),this.stepnumber+=1,this.dispatchEvent(ia);let _=!0;if(this.allowSleep)for(_=!1,x=0;x!==i;x++){const z=o[x];z.sleepTick(this.time),z.sleepState!==H.SLEEPING&&(_=!0)}this.hasActiveBodies=_}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(re,ae),t){for(let i=0,o=re.length;i<o;i+=2)We.bodyA=this.getBodyById(re[i]),We.bodyB=this.getBodyById(re[i+1]),this.dispatchEvent(We);We.bodyA=We.bodyB=null}if(e){for(let i=0,o=ae.length;i<o;i+=2)je.bodyA=this.getBodyById(ae[i]),je.bodyB=this.getBodyById(ae[i+1]),this.dispatchEvent(je);je.bodyA=je.bodyB=null}re.length=ae.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(re,ae),n){for(let i=0,o=re.length;i<o;i+=2){const r=this.getShapeById(re[i]),a=this.getShapeById(re[i+1]);ce.shapeA=r,ce.shapeB=a,r&&(ce.bodyA=r.body),a&&(ce.bodyB=a.body),this.dispatchEvent(ce)}ce.bodyA=ce.bodyB=ce.shapeA=ce.shapeB=null}if(s){for(let i=0,o=ae.length;i<o;i+=2){const r=this.getShapeById(ae[i]),a=this.getShapeById(ae[i+1]);le.shapeA=r,le.shapeB=a,r&&(le.bodyA=r.body),a&&(le.bodyB=a.body),this.dispatchEvent(le)}le.bodyA=le.bodyB=le.shapeA=le.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let n=0;n!==e;n++){const s=t[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new Ot;const Rn=new vt,zt=globalThis.performance||{};if(!zt.now){let y=Date.now();zt.timing&&zt.timing.navigationStart&&(y=zt.timing.navigationStart),zt.now=()=>Date.now()-y}new d;const ia={type:"postStep"},oa={type:"preStep"},He={type:H.COLLIDE_EVENT_NAME,body:null,contact:null},ra=[],aa=[],ca=[],la=[],re=[],ae=[],We={type:"beginContact",bodyA:null,bodyB:null},je={type:"endContact",bodyA:null,bodyB:null},ce={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},le={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};function ha(){const y=new sa({gravity:new d(0,-9.82,0)});return y.broadphase=new Ds,y.allowSleep=!1,y.defaultContactMaterial.friction=.45,y.defaultContactMaterial.restitution=.05,y}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var Ps=function(y){return URL.createObjectURL(new Blob([y],{type:"text/javascript"}))};try{URL.revokeObjectURL(Ps(""))}catch{Ps=function(t){return"data:application/javascript;charset=UTF-8,"+encodeURI(t)}}var Ht=Uint8Array,xe=Uint16Array,Un=Uint32Array,js=new Ht([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Us=new Ht([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ua=new Ht([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Xs=function(y,t){for(var e=new xe(31),n=0;n<31;++n)e[n]=t+=1<<y[n-1];for(var s=new Un(e[30]),n=1;n<30;++n)for(var i=e[n];i<e[n+1];++i)s[i]=i-e[n]<<5|n;return[e,s]},Ys=Xs(js,2),Ks=Ys[0],da=Ys[1];Ks[28]=258,da[258]=28;var pa=Xs(Us,0),fa=pa[0],Xn=new xe(32768);for(var dt=0;dt<32768;++dt){var we=(dt&43690)>>>1|(dt&21845)<<1;we=(we&52428)>>>2|(we&13107)<<2,we=(we&61680)>>>4|(we&3855)<<4,Xn[dt]=((we&65280)>>>8|(we&255)<<8)>>>1}var Ue=function(y,t,e){for(var n=y.length,s=0,i=new xe(t);s<n;++s)++i[y[s]-1];var o=new xe(t);for(s=0;s<t;++s)o[s]=o[s-1]+i[s-1]<<1;var r;if(e){r=new xe(1<<t);var a=15-t;for(s=0;s<n;++s)if(y[s])for(var c=s<<4|y[s],l=t-y[s],u=o[y[s]-1]++<<l,h=u|(1<<l)-1;u<=h;++u)r[Xn[u]>>>a]=c}else for(r=new xe(n),s=0;s<n;++s)y[s]&&(r[s]=Xn[o[y[s]-1]++]>>>15-y[s]);return r},Qe=new Ht(288);for(var dt=0;dt<144;++dt)Qe[dt]=8;for(var dt=144;dt<256;++dt)Qe[dt]=9;for(var dt=256;dt<280;++dt)Qe[dt]=7;for(var dt=280;dt<288;++dt)Qe[dt]=8;var Zs=new Ht(32);for(var dt=0;dt<32;++dt)Zs[dt]=5;var ma=Ue(Qe,9,1),ya=Ue(Zs,5,1),Ln=function(y){for(var t=y[0],e=1;e<y.length;++e)y[e]>t&&(t=y[e]);return t},Kt=function(y,t,e){var n=t/8|0;return(y[n]|y[n+1]<<8)>>(t&7)&e},kn=function(y,t){var e=t/8|0;return(y[e]|y[e+1]<<8|y[e+2]<<16)>>(t&7)},wa=function(y){return(y/8|0)+(y&7&&1)},xa=function(y,t,e){(e==null||e>y.length)&&(e=y.length);var n=new(y instanceof xe?xe:y instanceof Un?Un:Ht)(e-t);return n.set(y.subarray(t,e)),n},ga=function(y,t,e){var n=y.length;if(!n||e&&!e.l&&n<5)return t||new Ht(0);var s=!t||e,i=!e||e.i;e||(e={}),t||(t=new Ht(n*3));var o=function(jt){var Qt=t.length;if(jt>Qt){var Oe=new Ht(Math.max(Qt*2,jt));Oe.set(t),t=Oe}},r=e.f||0,a=e.p||0,c=e.b||0,l=e.l,u=e.d,h=e.m,f=e.n,p=n*8;do{if(!l){e.f=r=Kt(y,a,1);var w=Kt(y,a+1,3);if(a+=3,w)if(w==1)l=ma,u=ya,h=9,f=5;else if(w==2){var M=Kt(y,a,31)+257,E=Kt(y,a+10,15)+4,P=M+Kt(y,a+5,31)+1;a+=14;for(var S=new Ht(P),V=new Ht(19),O=0;O<E;++O)V[ua[O]]=Kt(y,a+O*3,7);a+=E*3;for(var K=Ln(V),I=(1<<K)-1,W=Ue(V,K,1),O=0;O<P;){var _=W[Kt(y,a,I)];a+=_&15;var m=_>>>4;if(m<16)S[O++]=m;else{var z=0,R=0;for(m==16?(R=3+Kt(y,a,3),a+=2,z=S[O-1]):m==17?(R=3+Kt(y,a,7),a+=3):m==18&&(R=11+Kt(y,a,127),a+=7);R--;)S[O++]=z}}var k=S.subarray(0,M),T=S.subarray(M);h=Ln(k),f=Ln(T),l=Ue(k,h,1),u=Ue(T,f,1)}else throw"invalid block type";else{var m=wa(a)+4,v=y[m-4]|y[m-3]<<8,x=m+v;if(x>n){if(i)throw"unexpected EOF";break}s&&o(c+v),t.set(y.subarray(m,x),c),e.b=c+=v,e.p=a=x*8;continue}if(a>p){if(i)throw"unexpected EOF";break}}s&&o(c+131072);for(var it=(1<<h)-1,nt=(1<<f)-1,et=a;;et=a){var z=l[kn(y,a)&it],pt=z>>>4;if(a+=z&15,a>p){if(i)throw"unexpected EOF";break}if(!z)throw"invalid length/literal";if(pt<256)t[c++]=pt;else if(pt==256){et=a,l=null;break}else{var wt=pt-254;if(pt>264){var O=pt-257,$=js[O];wt=Kt(y,a,(1<<$)-1)+Ks[O],a+=$}var At=u[kn(y,a)&nt],qt=At>>>4;if(!At)throw"invalid distance";a+=At&15;var T=fa[qt];if(qt>3){var $=Us[qt];T+=kn(y,a)&(1<<$)-1,a+=$}if(a>p){if(i)throw"unexpected EOF";break}s&&o(c+131072);for(var se=c+wt;c<se;c+=4)t[c]=t[c-T],t[c+1]=t[c+1-T],t[c+2]=t[c+2-T],t[c+3]=t[c+3-T];c=se}}e.l=l,e.p=et,e.b=c,l&&(r=1,e.m=h,e.d=u,e.n=f)}while(!r);return c==t.length?t:xa(t,0,c)},va=new Ht(0),ba=function(y){if((y[0]&15)!=8||y[0]>>>4>7||(y[0]<<8|y[1])%31)throw"invalid zlib data";if(y[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Ma(y,t){return ga((ba(y),y.subarray(2,-4)),t)}var za=typeof TextDecoder<"u"&&new TextDecoder,Aa=0;try{za.decode(va,{stream:!0}),Aa=1}catch{}function Qs(y,t,e){const n=e.length-y-1;if(t>=e[n])return n-1;if(t<=e[y])return y;let s=y,i=n,o=Math.floor((s+i)/2);for(;t<e[o]||t>=e[o+1];)t<e[o]?i=o:s=o,o=Math.floor((s+i)/2);return o}function Ea(y,t,e,n){const s=[],i=[],o=[];s[0]=1;for(let r=1;r<=e;++r){i[r]=t-n[y+1-r],o[r]=n[y+r]-t;let a=0;for(let c=0;c<r;++c){const l=o[c+1],u=i[r-c],h=s[c]/(l+u);s[c]=a+l*h,a=u*h}s[r]=a}return s}function Sa(y,t,e,n){const s=Qs(y,n,t),i=Ea(s,n,y,t),o=new mn(0,0,0,0);for(let r=0;r<=y;++r){const a=e[s-y+r],c=i[r],l=a.w*c;o.x+=a.x*l,o.y+=a.y*l,o.z+=a.z*l,o.w+=a.w*c}return o}function Ca(y,t,e,n,s){const i=[];for(let u=0;u<=e;++u)i[u]=0;const o=[];for(let u=0;u<=n;++u)o[u]=i.slice(0);const r=[];for(let u=0;u<=e;++u)r[u]=i.slice(0);r[0][0]=1;const a=i.slice(0),c=i.slice(0);for(let u=1;u<=e;++u){a[u]=t-s[y+1-u],c[u]=s[y+u]-t;let h=0;for(let f=0;f<u;++f){const p=c[f+1],w=a[u-f];r[u][f]=p+w;const m=r[f][u-1]/r[u][f];r[f][u]=h+p*m,h=w*m}r[u][u]=h}for(let u=0;u<=e;++u)o[0][u]=r[u][e];for(let u=0;u<=e;++u){let h=0,f=1;const p=[];for(let w=0;w<=e;++w)p[w]=i.slice(0);p[0][0]=1;for(let w=1;w<=n;++w){let m=0;const v=u-w,x=e-w;u>=w&&(p[f][0]=p[h][0]/r[x+1][v],m=p[f][0]*r[v][x]);const M=v>=-1?1:-v,E=u-1<=x?w-1:e-u;for(let S=M;S<=E;++S)p[f][S]=(p[h][S]-p[h][S-1])/r[x+1][v+S],m+=p[f][S]*r[v+S][x];u<=x&&(p[f][w]=-p[h][w-1]/r[x+1][u],m+=p[f][w]*r[u][x]),o[w][u]=m;const P=h;h=f,f=P}}let l=e;for(let u=1;u<=n;++u){for(let h=0;h<=e;++h)o[u][h]*=l;l*=e-u}return o}function Ba(y,t,e,n,s){const i=s<y?s:y,o=[],r=Qs(y,n,t),a=Ca(r,n,y,i,t),c=[];for(let l=0;l<e.length;++l){const u=e[l].clone(),h=u.w;u.x*=h,u.y*=h,u.z*=h,c[l]=u}for(let l=0;l<=i;++l){const u=c[r-y].clone().multiplyScalar(a[l][0]);for(let h=1;h<=y;++h)u.add(c[r-y+h].clone().multiplyScalar(a[l][h]));o[l]=u}for(let l=i+1;l<=s+1;++l)o[l]=new mn(0,0,0);return o}function Ta(y,t){let e=1;for(let s=2;s<=y;++s)e*=s;let n=1;for(let s=2;s<=t;++s)n*=s;for(let s=2;s<=y-t;++s)n*=s;return e/n}function Pa(y){const t=y.length,e=[],n=[];for(let i=0;i<t;++i){const o=y[i];e[i]=new Wt(o.x,o.y,o.z),n[i]=o.w}const s=[];for(let i=0;i<t;++i){const o=e[i].clone();for(let r=1;r<=i;++r)o.sub(s[i-r].clone().multiplyScalar(Ta(i,r)*n[r]));s[i]=o.divideScalar(n[0])}return s}function Ia(y,t,e,n,s){const i=Ba(y,t,e,n,s);return Pa(i)}class Fa extends di{constructor(t,e,n,s,i){super(),this.degree=t,this.knots=e,this.controlPoints=[],this.startKnot=s||0,this.endKnot=i||this.knots.length-1;for(let o=0;o<n.length;++o){const r=n[o];this.controlPoints[o]=new mn(r.x,r.y,r.z,r.w)}}getPoint(t,e=new Wt){const n=e,s=this.knots[this.startKnot]+t*(this.knots[this.endKnot]-this.knots[this.startKnot]),i=Sa(this.degree,this.knots,this.controlPoints,s);return i.w!==1&&i.divideScalar(i.w),n.set(i.x,i.y,i.z)}getTangent(t,e=new Wt){const n=e,s=this.knots[0]+t*(this.knots[this.knots.length-1]-this.knots[0]),i=Ia(this.degree,this.knots,this.controlPoints,s,1);return n.copy(i[1]).normalize(),n}}let st,gt,Ft;class $s extends jn{constructor(t){super(t)}load(t,e,n,s){const i=this,o=i.path===""?pi.extractUrlBase(t):i.path,r=new fi(this.manager);r.setPath(i.path),r.setResponseType("arraybuffer"),r.setRequestHeader(i.requestHeader),r.setWithCredentials(i.withCredentials),r.load(t,function(a){try{e(i.parse(a,o))}catch(c){s?s(c):console.error(c),i.manager.itemError(t)}},n,s)}parse(t,e){if(Na(t))st=new Da().parse(t);else{const s=ni(t);if(!Oa(s))throw new Error("THREE.FBXLoader: Unknown format.");if(Fs(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Fs(s));st=new Va().parse(s)}const n=new mi(this.manager).setPath(this.resourcePath||e).setCrossOrigin(this.crossOrigin);return new Ra(n,this.manager).parse(st)}}class Ra{constructor(t,e){this.textureLoader=t,this.manager=e}parse(){gt=this.parseConnections();const t=this.parseImages(),e=this.parseTextures(t),n=this.parseMaterials(e),s=this.parseDeformers(),i=new La().parse(s);return this.parseScene(s,i,n),Ft}parseConnections(){const t=new Map;return"Connections"in st&&st.Connections.connections.forEach(function(n){const s=n[0],i=n[1],o=n[2];t.has(s)||t.set(s,{parents:[],children:[]});const r={ID:i,relationship:o};t.get(s).parents.push(r),t.has(i)||t.set(i,{parents:[],children:[]});const a={ID:s,relationship:o};t.get(i).children.push(a)}),t}parseImages(){const t={},e={};if("Video"in st.Objects){const n=st.Objects.Video;for(const s in n){const i=n[s],o=parseInt(s);if(t[o]=i.RelativeFilename||i.Filename,"Content"in i){const r=i.Content instanceof ArrayBuffer&&i.Content.byteLength>0,a=typeof i.Content=="string"&&i.Content!=="";if(r||a){const c=this.parseImage(n[s]);e[i.RelativeFilename||i.Filename]=c}}}}for(const n in t){const s=t[n];e[s]!==void 0?t[n]=e[s]:t[n]=t[n].split("\\").pop()}return t}parseImage(t){const e=t.Content,n=t.RelativeFilename||t.Filename,s=n.slice(n.lastIndexOf(".")+1).toLowerCase();let i;switch(s){case"bmp":i="image/bmp";break;case"jpg":case"jpeg":i="image/jpeg";break;case"png":i="image/png";break;case"tif":i="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),i="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof e=="string")return"data:"+i+";base64,"+e;{const o=new Uint8Array(e);return window.URL.createObjectURL(new Blob([o],{type:i}))}}parseTextures(t){const e=new Map;if("Texture"in st.Objects){const n=st.Objects.Texture;for(const s in n){const i=this.parseTexture(n[s],t);e.set(parseInt(s),i)}}return e}parseTexture(t,e){const n=this.loadTexture(t,e);n.ID=t.id,n.name=t.attrName;const s=t.WrapModeU,i=t.WrapModeV,o=s!==void 0?s.value:0,r=i!==void 0?i.value:0;if(n.wrapS=o===0?os:rs,n.wrapT=r===0?os:rs,"Scaling"in t){const a=t.Scaling.value;n.repeat.x=a[0],n.repeat.y=a[1]}if("Translation"in t){const a=t.Translation.value;n.offset.x=a[0],n.offset.y=a[1]}return n}loadTexture(t,e){let n;const s=this.textureLoader.path,i=gt.get(t.id).children;i!==void 0&&i.length>0&&e[i[0].ID]!==void 0&&(n=e[i[0].ID],(n.indexOf("blob:")===0||n.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let o;const r=t.FileName.slice(-3).toLowerCase();if(r==="tga"){const a=this.manager.getHandler(".tga");a===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",t.RelativeFilename),o=new An):(a.setPath(this.textureLoader.path),o=a.load(n))}else if(r==="dds"){const a=this.manager.getHandler(".dds");a===null?(console.warn("FBXLoader: DDS loader not found, creating placeholder texture for",t.RelativeFilename),o=new An):(a.setPath(this.textureLoader.path),o=a.load(n))}else r==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",t.RelativeFilename),o=new An):o=this.textureLoader.load(n);return this.textureLoader.setPath(s),o}parseMaterials(t){const e=new Map;if("Material"in st.Objects){const n=st.Objects.Material;for(const s in n){const i=this.parseMaterial(n[s],t);i!==null&&e.set(parseInt(s),i)}}return e}parseMaterial(t,e){const n=t.id,s=t.attrName;let i=t.ShadingModel;if(typeof i=="object"&&(i=i.value),!gt.has(n))return null;const o=this.parseParameters(t,e,n);let r;switch(i.toLowerCase()){case"phong":r=new En;break;case"lambert":r=new yi;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',i),r=new En;break}return r.setValues(o),r.name=s,r}parseParameters(t,e,n){const s={};t.BumpFactor&&(s.bumpScale=t.BumpFactor.value),t.Diffuse?s.color=new he().fromArray(t.Diffuse.value).convertSRGBToLinear():t.DiffuseColor&&(t.DiffuseColor.type==="Color"||t.DiffuseColor.type==="ColorRGB")&&(s.color=new he().fromArray(t.DiffuseColor.value).convertSRGBToLinear()),t.DisplacementFactor&&(s.displacementScale=t.DisplacementFactor.value),t.Emissive?s.emissive=new he().fromArray(t.Emissive.value).convertSRGBToLinear():t.EmissiveColor&&(t.EmissiveColor.type==="Color"||t.EmissiveColor.type==="ColorRGB")&&(s.emissive=new he().fromArray(t.EmissiveColor.value).convertSRGBToLinear()),t.EmissiveFactor&&(s.emissiveIntensity=parseFloat(t.EmissiveFactor.value)),t.Opacity&&(s.opacity=parseFloat(t.Opacity.value)),s.opacity<1&&(s.transparent=!0),t.ReflectionFactor&&(s.reflectivity=t.ReflectionFactor.value),t.Shininess&&(s.shininess=t.Shininess.value),t.Specular?s.specular=new he().fromArray(t.Specular.value).convertSRGBToLinear():t.SpecularColor&&t.SpecularColor.type==="Color"&&(s.specular=new he().fromArray(t.SpecularColor.value).convertSRGBToLinear());const i=this;return gt.get(n).children.forEach(function(o){const r=o.relationship;switch(r){case"Bump":s.bumpMap=i.getTexture(e,o.ID);break;case"Maya|TEX_ao_map":s.aoMap=i.getTexture(e,o.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=i.getTexture(e,o.ID),s.map!==void 0&&(s.map.colorSpace=en);break;case"DisplacementColor":s.displacementMap=i.getTexture(e,o.ID);break;case"EmissiveColor":s.emissiveMap=i.getTexture(e,o.ID),s.emissiveMap!==void 0&&(s.emissiveMap.colorSpace=en);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=i.getTexture(e,o.ID);break;case"ReflectionColor":s.envMap=i.getTexture(e,o.ID),s.envMap!==void 0&&(s.envMap.mapping=wi,s.envMap.colorSpace=en);break;case"SpecularColor":s.specularMap=i.getTexture(e,o.ID),s.specularMap!==void 0&&(s.specularMap.colorSpace=en);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=i.getTexture(e,o.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",r);break}}),s}getTexture(t,e){return"LayeredTexture"in st.Objects&&e in st.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),e=gt.get(e).children[0].ID),t.get(e)}parseDeformers(){const t={},e={};if("Deformer"in st.Objects){const n=st.Objects.Deformer;for(const s in n){const i=n[s],o=gt.get(parseInt(s));if(i.attrType==="Skin"){const r=this.parseSkeleton(o,n);r.ID=s,o.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),r.geometryID=o.parents[0].ID,t[s]=r}else if(i.attrType==="BlendShape"){const r={id:s};r.rawTargets=this.parseMorphTargets(o,n),r.id=s,o.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),e[s]=r}}}return{skeletons:t,morphTargets:e}}parseSkeleton(t,e){const n=[];return t.children.forEach(function(s){const i=e[s.ID];if(i.attrType!=="Cluster")return;const o={ID:s.ID,indices:[],weights:[],transformLink:new xt().fromArray(i.TransformLink.a)};"Indexes"in i&&(o.indices=i.Indexes.a,o.weights=i.Weights.a),n.push(o)}),{rawBones:n,bones:[]}}parseMorphTargets(t,e){const n=[];for(let s=0;s<t.children.length;s++){const i=t.children[s],o=e[i.ID],r={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if(o.attrType!=="BlendShapeChannel")return;r.geoID=gt.get(parseInt(i.ID)).children.filter(function(a){return a.relationship===void 0})[0].ID,n.push(r)}return n}parseScene(t,e,n){Ft=new as;const s=this.parseModels(t.skeletons,e,n),i=st.Objects.Model,o=this;s.forEach(function(a){const c=i[a.ID];o.setLookAtProperties(a,c),gt.get(a.ID).parents.forEach(function(u){const h=s.get(u.ID);h!==void 0&&h.add(a)}),a.parent===null&&Ft.add(a)}),this.bindSkeleton(t.skeletons,e,s),this.addGlobalSceneSettings(),Ft.traverse(function(a){if(a.userData.transformData){a.parent&&(a.userData.transformData.parentMatrix=a.parent.matrix,a.userData.transformData.parentMatrixWorld=a.parent.matrixWorld);const c=ti(a.userData.transformData);a.applyMatrix4(c),a.updateWorldMatrix()}});const r=new ka().parse();Ft.children.length===1&&Ft.children[0].isGroup&&(Ft.children[0].animations=r,Ft=Ft.children[0]),Ft.animations=r}parseModels(t,e,n){const s=new Map,i=st.Objects.Model;for(const o in i){const r=parseInt(o),a=i[o],c=gt.get(r);let l=this.buildSkeleton(c,t,r,a.attrName);if(!l){switch(a.attrType){case"Camera":l=this.createCamera(c);break;case"Light":l=this.createLight(c);break;case"Mesh":l=this.createMesh(c,e,n);break;case"NurbsCurve":l=this.createCurve(c,e);break;case"LimbNode":case"Root":l=new cs;break;case"Null":default:l=new as;break}l.name=a.attrName?un.sanitizeNodeName(a.attrName):"",l.userData.originalName=a.attrName,l.ID=r}this.getTransformData(l,a),s.set(r,l)}return s}buildSkeleton(t,e,n,s){let i=null;return t.parents.forEach(function(o){for(const r in e){const a=e[r];a.rawBones.forEach(function(c,l){if(c.ID===o.ID){const u=i;i=new cs,i.matrixWorld.copy(c.transformLink),i.name=s?un.sanitizeNodeName(s):"",i.userData.originalName=s,i.ID=n,a.bones[l]=i,u!==null&&i.add(u)}})}}),i}createCamera(t){let e,n;if(t.children.forEach(function(s){const i=st.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)e=new Sn;else{let s=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(s=1);let i=1;n.NearPlane!==void 0&&(i=n.NearPlane.value/1e3);let o=1e3;n.FarPlane!==void 0&&(o=n.FarPlane.value/1e3);let r=window.innerWidth,a=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(r=n.AspectWidth.value,a=n.AspectHeight.value);const c=r/a;let l=45;n.FieldOfView!==void 0&&(l=n.FieldOfView.value);const u=n.FocalLength?n.FocalLength.value:null;switch(s){case 0:e=new gi(l,c,i,o),u!==null&&e.setFocalLength(u);break;case 1:e=new xi(-r/2,r/2,a/2,-a/2,i,o);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),e=new Sn;break}}return e}createLight(t){let e,n;if(t.children.forEach(function(s){const i=st.Objects.NodeAttribute[s.ID];i!==void 0&&(n=i)}),n===void 0)e=new Sn;else{let s;n.LightType===void 0?s=0:s=n.LightType.value;let i=16777215;n.Color!==void 0&&(i=new he().fromArray(n.Color.value).convertSRGBToLinear());let o=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(o=0);let r=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?r=0:r=n.FarAttenuationEnd.value);const a=1;switch(s){case 0:e=new ls(i,o,r,a);break;case 1:e=new bi(i,o);break;case 2:let c=Math.PI/3;n.InnerAngle!==void 0&&(c=Rt.degToRad(n.InnerAngle.value));let l=0;n.OuterAngle!==void 0&&(l=Rt.degToRad(n.OuterAngle.value),l=Math.max(l,1)),e=new vi(i,o,r,c,l,a);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),e=new ls(i,o);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(e.castShadow=!0)}return e}createMesh(t,e,n){let s,i=null,o=null;const r=[];return t.children.forEach(function(a){e.has(a.ID)&&(i=e.get(a.ID)),n.has(a.ID)&&r.push(n.get(a.ID))}),r.length>1?o=r:r.length>0?o=r[0]:(o=new En({name:jn.DEFAULT_MATERIAL_NAME,color:13421772}),r.push(o)),"color"in i.attributes&&r.forEach(function(a){a.vertexColors=!0}),i.FBX_Deformer?(s=new Mi(i,o),s.normalizeSkinWeights()):s=new zi(i,o),s}createCurve(t,e){const n=t.children.reduce(function(i,o){return e.has(o.ID)&&(i=e.get(o.ID)),i},null),s=new Ai({name:jn.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new Ei(n,s)}getTransformData(t,e){const n={};"InheritType"in e&&(n.inheritType=parseInt(e.InheritType.value)),"RotationOrder"in e?n.eulerOrder=ei(e.RotationOrder.value):n.eulerOrder="ZYX","Lcl_Translation"in e&&(n.translation=e.Lcl_Translation.value),"PreRotation"in e&&(n.preRotation=e.PreRotation.value),"Lcl_Rotation"in e&&(n.rotation=e.Lcl_Rotation.value),"PostRotation"in e&&(n.postRotation=e.PostRotation.value),"Lcl_Scaling"in e&&(n.scale=e.Lcl_Scaling.value),"ScalingOffset"in e&&(n.scalingOffset=e.ScalingOffset.value),"ScalingPivot"in e&&(n.scalingPivot=e.ScalingPivot.value),"RotationOffset"in e&&(n.rotationOffset=e.RotationOffset.value),"RotationPivot"in e&&(n.rotationPivot=e.RotationPivot.value),t.userData.transformData=n}setLookAtProperties(t,e){"LookAtProperty"in e&&gt.get(t.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const i=st.Objects.Model[s.ID];if("Lcl_Translation"in i){const o=i.Lcl_Translation.value;t.target!==void 0?(t.target.position.fromArray(o),Ft.add(t.target)):t.lookAt(new Wt().fromArray(o))}}})}bindSkeleton(t,e,n){const s=this.parsePoseNodes();for(const i in t){const o=t[i];gt.get(parseInt(o.ID)).parents.forEach(function(a){if(e.has(a.ID)){const c=a.ID;gt.get(c).parents.forEach(function(u){n.has(u.ID)&&n.get(u.ID).bind(new Si(o.bones),s[u.ID])})}})}}parsePoseNodes(){const t={};if("Pose"in st.Objects){const e=st.Objects.Pose;for(const n in e)if(e[n].attrType==="BindPose"&&e[n].NbPoseNodes>0){const s=e[n].PoseNode;Array.isArray(s)?s.forEach(function(i){t[i.Node]=new xt().fromArray(i.Matrix.a)}):t[s.Node]=new xt().fromArray(s.Matrix.a)}}return t}addGlobalSceneSettings(){if("GlobalSettings"in st){if("AmbientColor"in st.GlobalSettings){const t=st.GlobalSettings.AmbientColor.value,e=t[0],n=t[1],s=t[2];if(e!==0||n!==0||s!==0){const i=new he(e,n,s).convertSRGBToLinear();Ft.add(new Ci(i,1))}}"UnitScaleFactor"in st.GlobalSettings&&(Ft.userData.unitScaleFactor=st.GlobalSettings.UnitScaleFactor.value)}}}class La{constructor(){this.negativeMaterialIndices=!1}parse(t){const e=new Map;if("Geometry"in st.Objects){const n=st.Objects.Geometry;for(const s in n){const i=gt.get(parseInt(s)),o=this.parseGeometry(i,n[s],t);e.set(parseInt(s),o)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),e}parseGeometry(t,e,n){switch(e.attrType){case"Mesh":return this.parseMeshGeometry(t,e,n);case"NurbsCurve":return this.parseNurbsGeometry(e)}}parseMeshGeometry(t,e,n){const s=n.skeletons,i=[],o=t.parents.map(function(u){return st.Objects.Model[u.ID]});if(o.length===0)return;const r=t.children.reduce(function(u,h){return s[h.ID]!==void 0&&(u=s[h.ID]),u},null);t.children.forEach(function(u){n.morphTargets[u.ID]!==void 0&&i.push(n.morphTargets[u.ID])});const a=o[0],c={};"RotationOrder"in a&&(c.eulerOrder=ei(a.RotationOrder.value)),"InheritType"in a&&(c.inheritType=parseInt(a.InheritType.value)),"GeometricTranslation"in a&&(c.translation=a.GeometricTranslation.value),"GeometricRotation"in a&&(c.rotation=a.GeometricRotation.value),"GeometricScaling"in a&&(c.scale=a.GeometricScaling.value);const l=ti(c);return this.genGeometry(e,r,i,l)}genGeometry(t,e,n,s){const i=new Cn;t.attrName&&(i.name=t.attrName);const o=this.parseGeoNode(t,e),r=this.genBuffers(o),a=new Pe(r.vertex,3);if(a.applyMatrix4(s),i.setAttribute("position",a),r.colors.length>0&&i.setAttribute("color",new Pe(r.colors,3)),e&&(i.setAttribute("skinIndex",new Bi(r.weightsIndices,4)),i.setAttribute("skinWeight",new Pe(r.vertexWeights,4)),i.FBX_Deformer=e),r.normal.length>0){const c=new Ti().getNormalMatrix(s),l=new Pe(r.normal,3);l.applyNormalMatrix(c),i.setAttribute("normal",l)}if(r.uvs.forEach(function(c,l){const u=l===0?"uv":`uv${l}`;i.setAttribute(u,new Pe(r.uvs[l],2))}),o.material&&o.material.mappingType!=="AllSame"){let c=r.materialIndex[0],l=0;if(r.materialIndex.forEach(function(u,h){u!==c&&(i.addGroup(l,h-l,c),c=u,l=h)}),i.groups.length>0){const u=i.groups[i.groups.length-1],h=u.start+u.count;h!==r.materialIndex.length&&i.addGroup(h,r.materialIndex.length-h,c)}i.groups.length===0&&i.addGroup(0,r.materialIndex.length,r.materialIndex[0])}return this.addMorphTargets(i,t,n,s),i}parseGeoNode(t,e){const n={};if(n.vertexPositions=t.Vertices!==void 0?t.Vertices.a:[],n.vertexIndices=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],t.LayerElementColor&&(n.color=this.parseVertexColors(t.LayerElementColor[0])),t.LayerElementMaterial&&(n.material=this.parseMaterialIndices(t.LayerElementMaterial[0])),t.LayerElementNormal&&(n.normal=this.parseNormals(t.LayerElementNormal[0])),t.LayerElementUV){n.uv=[];let s=0;for(;t.LayerElementUV[s];)t.LayerElementUV[s].UV&&n.uv.push(this.parseUVs(t.LayerElementUV[s])),s++}return n.weightTable={},e!==null&&(n.skeleton=e,e.rawBones.forEach(function(s,i){s.indices.forEach(function(o,r){n.weightTable[o]===void 0&&(n.weightTable[o]=[]),n.weightTable[o].push({id:i,weight:s.weights[r]})})})),n}genBuffers(t){const e={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,s=0,i=!1,o=[],r=[],a=[],c=[],l=[],u=[];const h=this;return t.vertexIndices.forEach(function(f,p){let w,m=!1;f<0&&(f=f^-1,m=!0);let v=[],x=[];if(o.push(f*3,f*3+1,f*3+2),t.color){const M=cn(p,n,f,t.color);a.push(M[0],M[1],M[2])}if(t.skeleton){if(t.weightTable[f]!==void 0&&t.weightTable[f].forEach(function(M){x.push(M.weight),v.push(M.id)}),x.length>4){i||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),i=!0);const M=[0,0,0,0],E=[0,0,0,0];x.forEach(function(P,S){let V=P,O=v[S];E.forEach(function(K,I,W){if(V>K){W[I]=V,V=K;const _=M[I];M[I]=O,O=_}})}),v=M,x=E}for(;x.length<4;)x.push(0),v.push(0);for(let M=0;M<4;++M)l.push(x[M]),u.push(v[M])}if(t.normal){const M=cn(p,n,f,t.normal);r.push(M[0],M[1],M[2])}t.material&&t.material.mappingType!=="AllSame"&&(w=cn(p,n,f,t.material)[0],w<0&&(h.negativeMaterialIndices=!0,w=0)),t.uv&&t.uv.forEach(function(M,E){const P=cn(p,n,f,M);c[E]===void 0&&(c[E]=[]),c[E].push(P[0]),c[E].push(P[1])}),s++,m&&(h.genFace(e,t,o,w,r,a,c,l,u,s),n++,s=0,o=[],r=[],a=[],c=[],l=[],u=[])}),e}getNormalNewell(t){const e=new Wt(0,0,0);for(let n=0;n<t.length;n++){const s=t[n],i=t[(n+1)%t.length];e.x+=(s.y-i.y)*(s.z+i.z),e.y+=(s.z-i.z)*(s.x+i.x),e.z+=(s.x-i.x)*(s.y+i.y)}return e.normalize(),e}getNormalTangentAndBitangent(t){const e=this.getNormalNewell(t),s=(Math.abs(e.z)>.5?new Wt(0,1,0):new Wt(0,0,1)).cross(e).normalize(),i=e.clone().cross(s).normalize();return{normal:e,tangent:s,bitangent:i}}flattenVertex(t,e,n){return new Pi(t.dot(e),t.dot(n))}genFace(t,e,n,s,i,o,r,a,c,l){let u;if(l>3){const h=[];for(let m=0;m<n.length;m+=3)h.push(new Wt(e.vertexPositions[n[m]],e.vertexPositions[n[m+1]],e.vertexPositions[n[m+2]]));const{tangent:f,bitangent:p}=this.getNormalTangentAndBitangent(h),w=[];for(const m of h)w.push(this.flattenVertex(m,f,p));u=Ii.triangulateShape(w,[])}else u=[[0,1,2]];for(const[h,f,p]of u)t.vertex.push(e.vertexPositions[n[h*3]]),t.vertex.push(e.vertexPositions[n[h*3+1]]),t.vertex.push(e.vertexPositions[n[h*3+2]]),t.vertex.push(e.vertexPositions[n[f*3]]),t.vertex.push(e.vertexPositions[n[f*3+1]]),t.vertex.push(e.vertexPositions[n[f*3+2]]),t.vertex.push(e.vertexPositions[n[p*3]]),t.vertex.push(e.vertexPositions[n[p*3+1]]),t.vertex.push(e.vertexPositions[n[p*3+2]]),e.skeleton&&(t.vertexWeights.push(a[h*4]),t.vertexWeights.push(a[h*4+1]),t.vertexWeights.push(a[h*4+2]),t.vertexWeights.push(a[h*4+3]),t.vertexWeights.push(a[f*4]),t.vertexWeights.push(a[f*4+1]),t.vertexWeights.push(a[f*4+2]),t.vertexWeights.push(a[f*4+3]),t.vertexWeights.push(a[p*4]),t.vertexWeights.push(a[p*4+1]),t.vertexWeights.push(a[p*4+2]),t.vertexWeights.push(a[p*4+3]),t.weightsIndices.push(c[h*4]),t.weightsIndices.push(c[h*4+1]),t.weightsIndices.push(c[h*4+2]),t.weightsIndices.push(c[h*4+3]),t.weightsIndices.push(c[f*4]),t.weightsIndices.push(c[f*4+1]),t.weightsIndices.push(c[f*4+2]),t.weightsIndices.push(c[f*4+3]),t.weightsIndices.push(c[p*4]),t.weightsIndices.push(c[p*4+1]),t.weightsIndices.push(c[p*4+2]),t.weightsIndices.push(c[p*4+3])),e.color&&(t.colors.push(o[h*3]),t.colors.push(o[h*3+1]),t.colors.push(o[h*3+2]),t.colors.push(o[f*3]),t.colors.push(o[f*3+1]),t.colors.push(o[f*3+2]),t.colors.push(o[p*3]),t.colors.push(o[p*3+1]),t.colors.push(o[p*3+2])),e.material&&e.material.mappingType!=="AllSame"&&(t.materialIndex.push(s),t.materialIndex.push(s),t.materialIndex.push(s)),e.normal&&(t.normal.push(i[h*3]),t.normal.push(i[h*3+1]),t.normal.push(i[h*3+2]),t.normal.push(i[f*3]),t.normal.push(i[f*3+1]),t.normal.push(i[f*3+2]),t.normal.push(i[p*3]),t.normal.push(i[p*3+1]),t.normal.push(i[p*3+2])),e.uv&&e.uv.forEach(function(w,m){t.uvs[m]===void 0&&(t.uvs[m]=[]),t.uvs[m].push(r[m][h*2]),t.uvs[m].push(r[m][h*2+1]),t.uvs[m].push(r[m][f*2]),t.uvs[m].push(r[m][f*2+1]),t.uvs[m].push(r[m][p*2]),t.uvs[m].push(r[m][p*2+1])})}addMorphTargets(t,e,n,s){if(n.length===0)return;t.morphTargetsRelative=!0,t.morphAttributes.position=[];const i=this;n.forEach(function(o){o.rawTargets.forEach(function(r){const a=st.Objects.Geometry[r.geoID];a!==void 0&&i.genMorphGeometry(t,e,a,s,r.name)})})}genMorphGeometry(t,e,n,s,i){const o=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],r=n.Vertices!==void 0?n.Vertices.a:[],a=n.Indexes!==void 0?n.Indexes.a:[],c=t.attributes.position.count*3,l=new Float32Array(c);for(let p=0;p<a.length;p++){const w=a[p]*3;l[w]=r[p*3],l[w+1]=r[p*3+1],l[w+2]=r[p*3+2]}const u={vertexIndices:o,vertexPositions:l},h=this.genBuffers(u),f=new Pe(h.vertex,3);f.name=i||n.attrName,f.applyMatrix4(s),t.morphAttributes.position.push(f)}parseNormals(t){const e=t.MappingInformationType,n=t.ReferenceInformationType,s=t.Normals.a;let i=[];return n==="IndexToDirect"&&("NormalIndex"in t?i=t.NormalIndex.a:"NormalsIndex"in t&&(i=t.NormalsIndex.a)),{dataSize:3,buffer:s,indices:i,mappingType:e,referenceType:n}}parseUVs(t){const e=t.MappingInformationType,n=t.ReferenceInformationType,s=t.UV.a;let i=[];return n==="IndexToDirect"&&(i=t.UVIndex.a),{dataSize:2,buffer:s,indices:i,mappingType:e,referenceType:n}}parseVertexColors(t){const e=t.MappingInformationType,n=t.ReferenceInformationType,s=t.Colors.a;let i=[];n==="IndexToDirect"&&(i=t.ColorIndex.a);for(let o=0,r=new he;o<s.length;o+=4)r.fromArray(s,o).convertSRGBToLinear().toArray(s,o);return{dataSize:4,buffer:s,indices:i,mappingType:e,referenceType:n}}parseMaterialIndices(t){const e=t.MappingInformationType,n=t.ReferenceInformationType;if(e==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const s=t.Materials.a,i=[];for(let o=0;o<s.length;++o)i.push(o);return{dataSize:1,buffer:s,indices:i,mappingType:e,referenceType:n}}parseNurbsGeometry(t){const e=parseInt(t.Order);if(isNaN(e))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",t.Order,t.id),new Cn;const n=e-1,s=t.KnotVector.a,i=[],o=t.Points.a;for(let u=0,h=o.length;u<h;u+=4)i.push(new mn().fromArray(o,u));let r,a;if(t.Form==="Closed")i.push(i[0]);else if(t.Form==="Periodic"){r=n,a=s.length-1-r;for(let u=0;u<n;++u)i.push(i[u])}const l=new Fa(n,s,i,r,a).getPoints(i.length*12);return new Cn().setFromPoints(l)}}class ka{parse(){const t=[],e=this.parseClips();if(e!==void 0)for(const n in e){const s=e[n],i=this.addClip(s);t.push(i)}return t}parseClips(){if(st.Objects.AnimationCurve===void 0)return;const t=this.parseAnimationCurveNodes();this.parseAnimationCurves(t);const e=this.parseAnimationLayers(t);return this.parseAnimStacks(e)}parseAnimationCurveNodes(){const t=st.Objects.AnimationCurveNode,e=new Map;for(const n in t){const s=t[n];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const i={id:s.id,attr:s.attrName,curves:{}};e.set(i.id,i)}}return e}parseAnimationCurves(t){const e=st.Objects.AnimationCurve;for(const n in e){const s={id:e[n].id,times:e[n].KeyTime.a.map(qa),values:e[n].KeyValueFloat.a},i=gt.get(s.id);if(i!==void 0){const o=i.parents[0].ID,r=i.parents[0].relationship;r.match(/X/)?t.get(o).curves.x=s:r.match(/Y/)?t.get(o).curves.y=s:r.match(/Z/)?t.get(o).curves.z=s:r.match(/DeformPercent/)&&t.has(o)&&(t.get(o).curves.morph=s)}}}parseAnimationLayers(t){const e=st.Objects.AnimationLayer,n=new Map;for(const s in e){const i=[],o=gt.get(parseInt(s));o!==void 0&&(o.children.forEach(function(a,c){if(t.has(a.ID)){const l=t.get(a.ID);if(l.curves.x!==void 0||l.curves.y!==void 0||l.curves.z!==void 0){if(i[c]===void 0){const u=gt.get(a.ID).parents.filter(function(h){return h.relationship!==void 0})[0].ID;if(u!==void 0){const h=st.Objects.Model[u.toString()];if(h===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",a);return}const f={modelName:h.attrName?un.sanitizeNodeName(h.attrName):"",ID:h.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};Ft.traverse(function(p){p.ID===h.id&&(f.transform=p.matrix,p.userData.transformData&&(f.eulerOrder=p.userData.transformData.eulerOrder))}),f.transform||(f.transform=new xt),"PreRotation"in h&&(f.preRotation=h.PreRotation.value),"PostRotation"in h&&(f.postRotation=h.PostRotation.value),i[c]=f}}i[c]&&(i[c][l.attr]=l)}else if(l.curves.morph!==void 0){if(i[c]===void 0){const u=gt.get(a.ID).parents.filter(function(v){return v.relationship!==void 0})[0].ID,h=gt.get(u).parents[0].ID,f=gt.get(h).parents[0].ID,p=gt.get(f).parents[0].ID,w=st.Objects.Model[p],m={modelName:w.attrName?un.sanitizeNodeName(w.attrName):"",morphName:st.Objects.Deformer[u].attrName};i[c]=m}i[c][l.attr]=l}}}),n.set(parseInt(s),i))}return n}parseAnimStacks(t){const e=st.Objects.AnimationStack,n={};for(const s in e){const i=gt.get(parseInt(s)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const o=t.get(i[0].ID);n[s]={name:e[s].attrName,layer:o}}return n}addClip(t){let e=[];const n=this;return t.layer.forEach(function(s){e=e.concat(n.generateTracks(s))}),new Fi(t.name,-1,e)}generateTracks(t){const e=[];let n=new Wt,s=new Wt;if(t.transform&&t.transform.decompose(n,new me,s),n=n.toArray(),s=s.toArray(),t.T!==void 0&&Object.keys(t.T.curves).length>0){const i=this.generateVectorTrack(t.modelName,t.T.curves,n,"position");i!==void 0&&e.push(i)}if(t.R!==void 0&&Object.keys(t.R.curves).length>0){const i=this.generateRotationTrack(t.modelName,t.R.curves,t.preRotation,t.postRotation,t.eulerOrder);i!==void 0&&e.push(i)}if(t.S!==void 0&&Object.keys(t.S.curves).length>0){const i=this.generateVectorTrack(t.modelName,t.S.curves,s,"scale");i!==void 0&&e.push(i)}if(t.DeformPercent!==void 0){const i=this.generateMorphTrack(t);i!==void 0&&e.push(i)}return e}generateVectorTrack(t,e,n,s){const i=this.getTimesForAllAxes(e),o=this.getKeyframeTrackValues(i,e,n);return new Ri(t+"."+s,i,o)}generateRotationTrack(t,e,n,s,i){let o,r;if(e.x!==void 0&&e.y!==void 0&&e.z!==void 0){const u=this.interpolateRotations(e.x,e.y,e.z,i);o=u[0],r=u[1]}n!==void 0&&(n=n.map(Rt.degToRad),n.push(i),n=new ee().fromArray(n),n=new me().setFromEuler(n)),s!==void 0&&(s=s.map(Rt.degToRad),s.push(i),s=new ee().fromArray(s),s=new me().setFromEuler(s).invert());const a=new me,c=new ee,l=[];if(!r||!o)return new hs(t+".quaternion",[],[]);for(let u=0;u<r.length;u+=3)c.set(r[u],r[u+1],r[u+2],i),a.setFromEuler(c),n!==void 0&&a.premultiply(n),s!==void 0&&a.multiply(s),u>2&&new me().fromArray(l,(u-3)/3*4).dot(a)<0&&a.set(-a.x,-a.y,-a.z,-a.w),a.toArray(l,u/3*4);return new hs(t+".quaternion",o,l)}generateMorphTrack(t){const e=t.DeformPercent.curves.morph,n=e.values.map(function(i){return i/100}),s=Ft.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];return new Li(t.modelName+".morphTargetInfluences["+s+"]",e.times,n)}getTimesForAllAxes(t){let e=[];if(t.x!==void 0&&(e=e.concat(t.x.times)),t.y!==void 0&&(e=e.concat(t.y.times)),t.z!==void 0&&(e=e.concat(t.z.times)),e=e.sort(function(n,s){return n-s}),e.length>1){let n=1,s=e[0];for(let i=1;i<e.length;i++){const o=e[i];o!==s&&(e[n]=o,s=o,n++)}e=e.slice(0,n)}return e}getKeyframeTrackValues(t,e,n){const s=n,i=[];let o=-1,r=-1,a=-1;return t.forEach(function(c){if(e.x&&(o=e.x.times.indexOf(c)),e.y&&(r=e.y.times.indexOf(c)),e.z&&(a=e.z.times.indexOf(c)),o!==-1){const l=e.x.values[o];i.push(l),s[0]=l}else i.push(s[0]);if(r!==-1){const l=e.y.values[r];i.push(l),s[1]=l}else i.push(s[1]);if(a!==-1){const l=e.z.values[a];i.push(l),s[2]=l}else i.push(s[2])}),i}interpolateRotations(t,e,n,s){const i=[],o=[];i.push(t.times[0]),o.push(Rt.degToRad(t.values[0])),o.push(Rt.degToRad(e.values[0])),o.push(Rt.degToRad(n.values[0]));for(let r=1;r<t.values.length;r++){const a=[t.values[r-1],e.values[r-1],n.values[r-1]];if(isNaN(a[0])||isNaN(a[1])||isNaN(a[2]))continue;const c=a.map(Rt.degToRad),l=[t.values[r],e.values[r],n.values[r]];if(isNaN(l[0])||isNaN(l[1])||isNaN(l[2]))continue;const u=l.map(Rt.degToRad),h=[l[0]-a[0],l[1]-a[1],l[2]-a[2]],f=[Math.abs(h[0]),Math.abs(h[1]),Math.abs(h[2])];if(f[0]>=180||f[1]>=180||f[2]>=180){const w=Math.max(...f)/180,m=new ee(...c,s),v=new ee(...u,s),x=new me().setFromEuler(m),M=new me().setFromEuler(v);x.dot(M)&&M.set(-M.x,-M.y,-M.z,-M.w);const E=t.times[r-1],P=t.times[r]-E,S=new me,V=new ee;for(let O=0;O<1;O+=1/w)S.copy(x.clone().slerp(M.clone(),O)),i.push(E+O*P),V.setFromQuaternion(S,s),o.push(V.x),o.push(V.y),o.push(V.z)}else i.push(t.times[r]),o.push(Rt.degToRad(t.values[r])),o.push(Rt.degToRad(e.values[r])),o.push(Rt.degToRad(n.values[r]))}return[i,o]}}class Va{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(t){this.nodeStack.push(t),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(t,e){this.currentProp=t,this.currentPropName=e}parse(t){this.currentIndent=0,this.allNodes=new Js,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const e=this,n=t.split(/[\r\n]+/);return n.forEach(function(s,i){const o=s.match(/^[\s\t]*;/),r=s.match(/^[\s\t]*$/);if(o||r)return;const a=s.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),c=s.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=s.match("^\\t{"+(e.currentIndent-1)+"}}");a?e.parseNodeBegin(s,a):c?e.parseNodeProperty(s,c,n[++i]):l?e.popStack():s.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(t,e){const n=e[1].trim().replace(/^"/,"").replace(/"$/,""),s=e[2].split(",").map(function(a){return a.trim().replace(/^"/,"").replace(/"$/,"")}),i={name:n},o=this.parseNodeAttr(s),r=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,i):n in r?(n==="PoseNode"?r.PoseNode.push(i):r[n].id!==void 0&&(r[n]={},r[n][r[n].id]=r[n]),o.id!==""&&(r[n][o.id]=i)):typeof o.id=="number"?(r[n]={},r[n][o.id]=i):n!=="Properties70"&&(n==="PoseNode"?r[n]=[i]:r[n]=i),typeof o.id=="number"&&(i.id=o.id),o.name!==""&&(i.attrName=o.name),o.type!==""&&(i.attrType=o.type),this.pushStack(i)}parseNodeAttr(t){let e=t[0];t[0]!==""&&(e=parseInt(t[0]),isNaN(e)&&(e=t[0]));let n="",s="";return t.length>1&&(n=t[1].replace(/^(\w+)::/,""),s=t[2]),{id:e,name:n,type:s}}parseNodeProperty(t,e,n){let s=e[1].replace(/^"/,"").replace(/"$/,"").trim(),i=e[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&i===","&&(i=n.replace(/"/g,"").replace(/,$/,"").trim());const o=this.getCurrentNode();if(o.name==="Properties70"){this.parseNodeSpecialProperty(t,s,i);return}if(s==="C"){const a=i.split(",").slice(1),c=parseInt(a[0]),l=parseInt(a[1]);let u=i.split(",").slice(3);u=u.map(function(h){return h.trim().replace(/^"/,"")}),s="connections",i=[c,l],_a(i,u),o[s]===void 0&&(o[s]=[])}s==="Node"&&(o.id=i),s in o&&Array.isArray(o[s])?o[s].push(i):s!=="a"?o[s]=i:o.a=i,this.setCurrentProp(o,s),s==="a"&&i.slice(-1)!==","&&(o.a=Dn(i))}parseNodePropertyContinued(t){const e=this.getCurrentNode();e.a+=t,t.slice(-1)!==","&&(e.a=Dn(e.a))}parseNodeSpecialProperty(t,e,n){const s=n.split('",').map(function(l){return l.trim().replace(/^\"/,"").replace(/\s/,"_")}),i=s[0],o=s[1],r=s[2],a=s[3];let c=s[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=Dn(c);break}this.getPrevNode()[i]={type:o,type2:r,flag:a,value:c},this.setCurrentProp(this.getPrevNode(),i)}}class Da{parse(t){const e=new Is(t);e.skip(23);const n=e.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const s=new Js;for(;!this.endOfContent(e);){const i=this.parseNode(e,n);i!==null&&s.add(i.name,i)}return s}endOfContent(t){return t.size()%16===0?(t.getOffset()+160+16&-16)>=t.size():t.getOffset()+160+16>=t.size()}parseNode(t,e){const n={},s=e>=7500?t.getUint64():t.getUint32(),i=e>=7500?t.getUint64():t.getUint32();e>=7500?t.getUint64():t.getUint32();const o=t.getUint8(),r=t.getString(o);if(s===0)return null;const a=[];for(let h=0;h<i;h++)a.push(this.parseProperty(t));const c=a.length>0?a[0]:"",l=a.length>1?a[1]:"",u=a.length>2?a[2]:"";for(n.singleProperty=i===1&&t.getOffset()===s;s>t.getOffset();){const h=this.parseNode(t,e);h!==null&&this.parseSubNode(r,n,h)}return n.propertyList=a,typeof c=="number"&&(n.id=c),l!==""&&(n.attrName=l),u!==""&&(n.attrType=u),r!==""&&(n.name=r),n}parseSubNode(t,e,n){if(n.singleProperty===!0){const s=n.propertyList[0];Array.isArray(s)?(e[n.name]=n,n.a=s):e[n.name]=s}else if(t==="Connections"&&n.name==="C"){const s=[];n.propertyList.forEach(function(i,o){o!==0&&s.push(i)}),e.connections===void 0&&(e.connections=[]),e.connections.push(s)}else if(n.name==="Properties70")Object.keys(n).forEach(function(i){e[i]=n[i]});else if(t==="Properties70"&&n.name==="P"){let s=n.propertyList[0],i=n.propertyList[1];const o=n.propertyList[2],r=n.propertyList[3];let a;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),i.indexOf("Lcl ")===0&&(i=i.replace("Lcl ","Lcl_")),i==="Color"||i==="ColorRGB"||i==="Vector"||i==="Vector3D"||i.indexOf("Lcl_")===0?a=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:a=n.propertyList[4],e[s]={type:i,type2:o,flag:r,value:a}}else e[n.name]===void 0?typeof n.id=="number"?(e[n.name]={},e[n.name][n.id]=n):e[n.name]=n:n.name==="PoseNode"?(Array.isArray(e[n.name])||(e[n.name]=[e[n.name]]),e[n.name].push(n)):e[n.name][n.id]===void 0&&(e[n.name][n.id]=n)}parseProperty(t){const e=t.getString(1);let n;switch(e){case"C":return t.getBoolean();case"D":return t.getFloat64();case"F":return t.getFloat32();case"I":return t.getInt32();case"L":return t.getInt64();case"R":return n=t.getUint32(),t.getArrayBuffer(n);case"S":return n=t.getUint32(),t.getString(n);case"Y":return t.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=t.getUint32(),i=t.getUint32(),o=t.getUint32();if(i===0)switch(e){case"b":case"c":return t.getBooleanArray(s);case"d":return t.getFloat64Array(s);case"f":return t.getFloat32Array(s);case"i":return t.getInt32Array(s);case"l":return t.getInt64Array(s)}const r=Ma(new Uint8Array(t.getArrayBuffer(o))),a=new Is(r.buffer);switch(e){case"b":case"c":return a.getBooleanArray(s);case"d":return a.getFloat64Array(s);case"f":return a.getFloat32Array(s);case"i":return a.getInt32Array(s);case"l":return a.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+e)}}}class Is{constructor(t,e){this.dv=new DataView(t),this.offset=0,this.littleEndian=e!==void 0?e:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(t){this.offset+=t}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(t){const e=[];for(let n=0;n<t;n++)e.push(this.getBoolean());return e}getUint8(){const t=this.dv.getUint8(this.offset);return this.offset+=1,t}getInt16(){const t=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,t}getInt32(){const t=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,t}getInt32Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getInt32());return e}getUint32(){const t=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,t}getInt64(){let t,e;return this.littleEndian?(t=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),t=this.getUint32()),e&2147483648?(e=~e&4294967295,t=~t&4294967295,t===4294967295&&(e=e+1&4294967295),t=t+1&4294967295,-(e*4294967296+t)):e*4294967296+t}getInt64Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getInt64());return e}getUint64(){let t,e;return this.littleEndian?(t=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),t=this.getUint32()),e*4294967296+t}getFloat32(){const t=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,t}getFloat32Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getFloat32());return e}getFloat64(){const t=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,t}getFloat64Array(t){const e=[];for(let n=0;n<t;n++)e.push(this.getFloat64());return e}getArrayBuffer(t){const e=this.dv.buffer.slice(this.offset,this.offset+t);return this.offset+=t,e}getString(t){const e=this.offset;let n=new Uint8Array(this.dv.buffer,e,t);this.skip(t);const s=n.indexOf(0);return s>=0&&(n=new Uint8Array(this.dv.buffer,e,s)),this._textDecoder.decode(n)}}class Js{add(t,e){this[t]=e}}function Na(y){const t="Kaydara FBX Binary  \0";return y.byteLength>=t.length&&t===ni(y,0,t.length)}function Oa(y){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let e=0;function n(s){const i=y[s-1];return y=y.slice(e+s),e++,i}for(let s=0;s<t.length;++s)if(n(1)===t[s])return!1;return!0}function Fs(y){const t=/FBXVersion: (\d+)/,e=y.match(t);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function qa(y){return y/46186158e3}const Ga=[];function cn(y,t,e,n){let s;switch(n.mappingType){case"ByPolygonVertex":s=y;break;case"ByPolygon":s=t;break;case"ByVertice":s=e;break;case"AllSame":s=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(s=n.indices[s]);const i=s*n.dataSize,o=i+n.dataSize;return Ha(Ga,n.buffer,i,o)}const Vn=new ee,Re=new Wt;function ti(y){const t=new xt,e=new xt,n=new xt,s=new xt,i=new xt,o=new xt,r=new xt,a=new xt,c=new xt,l=new xt,u=new xt,h=new xt,f=y.inheritType?y.inheritType:0;if(y.translation&&t.setPosition(Re.fromArray(y.translation)),y.preRotation){const I=y.preRotation.map(Rt.degToRad);I.push(y.eulerOrder||ee.DEFAULT_ORDER),e.makeRotationFromEuler(Vn.fromArray(I))}if(y.rotation){const I=y.rotation.map(Rt.degToRad);I.push(y.eulerOrder||ee.DEFAULT_ORDER),n.makeRotationFromEuler(Vn.fromArray(I))}if(y.postRotation){const I=y.postRotation.map(Rt.degToRad);I.push(y.eulerOrder||ee.DEFAULT_ORDER),s.makeRotationFromEuler(Vn.fromArray(I)),s.invert()}y.scale&&i.scale(Re.fromArray(y.scale)),y.scalingOffset&&r.setPosition(Re.fromArray(y.scalingOffset)),y.scalingPivot&&o.setPosition(Re.fromArray(y.scalingPivot)),y.rotationOffset&&a.setPosition(Re.fromArray(y.rotationOffset)),y.rotationPivot&&c.setPosition(Re.fromArray(y.rotationPivot)),y.parentMatrixWorld&&(u.copy(y.parentMatrix),l.copy(y.parentMatrixWorld));const p=e.clone().multiply(n).multiply(s),w=new xt;w.extractRotation(l);const m=new xt;m.copyPosition(l);const v=m.clone().invert().multiply(l),x=w.clone().invert().multiply(v),M=i,E=new xt;if(f===0)E.copy(w).multiply(p).multiply(x).multiply(M);else if(f===1)E.copy(w).multiply(x).multiply(p).multiply(M);else{const W=new xt().scale(new Wt().setFromMatrixScale(u)).clone().invert(),_=x.clone().multiply(W);E.copy(w).multiply(p).multiply(_).multiply(M)}const P=c.clone().invert(),S=o.clone().invert();let V=t.clone().multiply(a).multiply(c).multiply(e).multiply(n).multiply(s).multiply(P).multiply(r).multiply(o).multiply(i).multiply(S);const O=new xt().copyPosition(V),K=l.clone().multiply(O);return h.copyPosition(K),V=h.clone().multiply(E),V.premultiply(l.invert()),V}function ei(y){y=y||0;const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return y===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[y]}function Dn(y){return y.split(",").map(function(e){return parseFloat(e)})}function ni(y,t,e){return t===void 0&&(t=0),e===void 0&&(e=y.byteLength),new TextDecoder().decode(new Uint8Array(y,t,e))}function _a(y,t){for(let e=0,n=y.length,s=t.length;e<s;e++,n++)y[n]=t[e]}function Ha(y,t,e,n){for(let s=e,i=0;s<n;s++,i++)y[i]=t[s];return y}function lt(y,t){return Math.random()*(t-y)+y}function Wa(y){return y[Math.floor(Math.random()*y.length)]}function Ce(y,t,e){return Math.min(e,Math.max(t,y))}class ja{constructor(t,e,n,s=new g.Vector3){j(this,"body");j(this,"mesh");j(this,"state","Idle");j(this,"onGround",!1);j(this,"mixer",null);j(this,"actions",{});j(this,"actionByKind",{});j(this,"currentAction",null);j(this,"animBaseSpeed",1.15);j(this,"camYaw",0);j(this,"camPitch",-.3);j(this,"camDist",4.5);j(this,"targetMouse",null);j(this,"pounceCooldown",0);j(this,"_raycaster",new g.Raycaster);this.world=t,this.scene=e,this.input=n,this.origin=s;const i=new xn(.45),o=10;this.body=new H({mass:o,shape:i,position:new d(s.x,s.y+.7,s.z)}),this.body.linearDamping=.05,this.body.angularDamping=1,this.body.fixedRotation=!0,t.addBody(this.body);const r=new g.Group;this.mesh=r,e.add(r),Promise.all([Ua(),Xa()]).then(([a,c])=>{const l=ki.clone(a);l.traverse(p=>{if(p.isSkinnedMesh||p.isMesh){p.castShadow=!0,p.receiveShadow=!0;const w=m=>{m&&"skinning"in m&&(p.isSkinnedMesh||p.isMesh)&&(m.skinning=!0)};if(c){const m=p.material,v=x=>{x&&"map"in x&&(x.map=c,"side"in x&&(x.side=g.DoubleSide),"needsUpdate"in x&&(x.needsUpdate=!0)),w(x)};Array.isArray(m)?m.forEach(v):v(m)}else if(p.material){const m=p.material;Array.isArray(m)?m.forEach(w):w(m)}p.frustumCulled=!1}});const u=new g.Box3().setFromObject(l),h=u.getCenter(new g.Vector3);l.position.x-=h.x,l.position.z-=h.z,l.position.y-=u.min.y,r.add(l);const f=a.animations||[];if(f&&f.length>0){this.mixer=new g.AnimationMixer(l),this.actions={};for(const v of f){const x=this.mixer.clipAction(v);x.loop=g.LoopRepeat,x.clampWhenFinished=!1,this.actions[v.name.toLowerCase()]=x}const p=Object.keys(this.actions),w=v=>p.find(x=>v.some(M=>x.includes(M)));this.actionByKind.idle=w(["idle","stand"])||p[0]||void 0,this.actionByKind.walk=w(["walk"])||this.actionByKind.idle,this.actionByKind.run=w(["run","jog","sprint"])||this.actionByKind.walk;const m=this.actionByKind.idle;m&&this.actions[m]&&(this.actions[m].reset().fadeIn(.2).play(),this.currentAction=m)}})}update(t,e,n,s=[]){var V,O,K;this.onGround=!1;const i=this.body.world,o=((V=i==null?void 0:i.narrowphase)==null?void 0:V.contactEquations)||[];for(const I of o)if(I.bi===this.body||I.bj===this.body){const W=I.ni,_=I.bi===this.body?-W.y:W.y,z=I.bi===this.body?I.bj:I.bi;if(_>.5){this.onGround=!0;break}if(z!=null&&z.isCouch&&_>.1){this.onGround=!0;break}}if(!this.onGround&&this.body&&this.body.world){const I=((O=this.body.world.gravity)==null?void 0:O.y)??-9.82;this.body.force.y+=this.body.mass*I}if(!this.onGround){const I=vt,W=Ye;if(I&&W){const _=new I,z=new W;if(_.from.set(this.body.position.x,this.body.position.y,this.body.position.z),_.to.set(this.body.position.x,this.body.position.y-.7,this.body.position.z),_.intersectWorld(this.body.world,{mode:I.ANY,result:z,skipBackfaces:!0}),z.hasHit&&z.body!==this.body){const R=this.body.position.y-z.hitPointWorld.y;R<=.75&&(this.onGround=!0),!this.onGround&&((K=z.body)!=null&&K.isCouch)&&R<=.9&&(this.onGround=!0)}}}if(this.mixer&&this.actions){const I=this.body.velocity.x,W=this.body.velocity.z,_=Math.hypot(I,W);let z="idle";_>3?z="run":_>.4&&(z="walk");const R=(this.actionByKind[z]||this.currentAction||"").toLowerCase();if(R&&R!==this.currentAction&&this.actions[R]){const T=this.actions[R],it=this.currentAction?this.actions[this.currentAction]:null;T.reset().fadeIn(.15).play(),it&&it.fadeOut(.15),this.currentAction=R}if(this.currentAction){const T=this.actions[this.currentAction];T&&(this.currentAction===(this.actionByKind.run||"").toLowerCase()?T.timeScale=g.MathUtils.clamp(_/4,.7,2):this.currentAction===(this.actionByKind.walk||"").toLowerCase()?T.timeScale=g.MathUtils.clamp(_/1.5,.6,1.6):T.timeScale=1)}const k=_<=.05||!this.onGround;this.mixer.timeScale=k?0:this.animBaseSpeed,this.mixer.update(t)}const r=this.input.consumeMouseDelta(),a=.002*this.input.sensitivity;this.camYaw-=r.x*a,this.camPitch-=r.y*a,this.camPitch=Ce(this.camPitch,-1.3,.3),this.camDist=Ce(this.camDist+this.input.consumeWheelDelta(),3,12);const c=this.input.forward-this.input.backward,l=this.input.right-this.input.left,u=Math.abs(c)+Math.abs(l)>0,h=12,f=h*1.75,w=this.input.sneak?2:this.input.run?f:h;if(this.onGround)if(this.input.jump){this.body.velocity.y=7,this.state="Jump";const W=this.body.velocity.x,_=this.body.velocity.z,z=Math.hypot(W,_),R=Math.min(1,z/f),k=45*Math.PI/180*R,T=7*Math.tan(k);if(z>1e-4&&z<T){const it=W/z,nt=_/z,et=T-z;this.body.velocity.x=W+it*et,this.body.velocity.z=_+nt*et}}else u?this.state=this.input.sneak?"Sneak":this.input.run?"Run":"Walk":this.state="Idle";else this.state!=="Pounce"&&(this.state="Jump");if(this.pounceCooldown=Math.max(0,this.pounceCooldown-t),this.input.consumeLockPounce()&&this.pounceCooldown<=0){let I=null,W=999;const _=new g.Vector3(this.body.position.x,this.body.position.y,this.body.position.z),z=new g.Vector3(Math.sin(this.camYaw),0,Math.cos(this.camYaw));for(const R of n){const k=R.position.distanceTo(_);k<8&&R.position.clone().sub(_).normalize().dot(z)>.6&&k<W&&(W=k,I=R)}if(I){this.targetMouse=I;const R=I.position.clone().sub(_).normalize();this.body.velocity.set(R.x*8,6.5,R.z*8),this.state="Pounce",this.pounceCooldown=1}}const m=new g.Vector3;if(u){this.body.wakeUp&&this.body.wakeUp();const I=this.camYaw,W=new g.Vector3(Math.sin(I),0,Math.cos(I)),_=new g.Vector3(-Math.cos(I),0,Math.sin(I));m.copy(W).multiplyScalar(c).add(_.multiplyScalar(l)).normalize();const z=this.body.velocity;if(this.onGround){const R=new d(m.x*w,z.y,m.z*w),k=.35;z.x+=(R.x-z.x)*k,z.z+=(R.z-z.z)*k}else z.x+=m.x*w*.5*t,z.z+=m.z*w*.5*t}else this.onGround&&(this.body.velocity.x*=.9,this.body.velocity.z*=.9);if(this.mesh.position.set(this.body.position.x,this.body.position.y-.45,this.body.position.z),m.lengthSq()>1e-4){const I=Math.atan2(m.x,m.z),W=this.mesh.rotation.y;let _=I-W;for(;_>Math.PI;)_-=Math.PI*2;for(;_<-Math.PI;)_+=Math.PI*2;let z;if(this.onGround)z=_*.2;else{const k=4*t;z=Ce(_,-k,k)}this.mesh.rotation.y=W+z}const v=new g.Vector3(this.body.position.x,this.body.position.y+.8,this.body.position.z),x=new g.Vector3(-Math.sin(this.camYaw)*this.camDist,0,-Math.cos(this.camYaw)*this.camDist);let M=v.clone().add(new g.Vector3(0,2.5+this.camPitch*-2,0)).add(x);const E=M.clone(),P=new g.Vector3().subVectors(E,v),S=P.length();if(S>.001&&s&&s.length>0){const I=P.normalize();this._raycaster.set(v,I),this._raycaster.far=S;const W=this._raycaster.intersectObjects(s,!0).filter(_=>{let z=_.object;for(;z;){if(z===this.mesh)return!1;z=z.parent}return!0});if(W.length>0){const z=W[0],R=Math.max(0,z.distance-.25);M.copy(v).add(I.multiplyScalar(R))}}e.position.lerp(M,.15),e.lookAt(v)}}let Nn=null;function Ua(){if(!Nn){const y=new $s;Nn=new Promise((t,e)=>{const n=new URL("/assets/cat-w_S28Lp9.fbx",import.meta.url).toString();y.load(n,s=>{const i=new g.Box3().setFromObject(s),o=new g.Vector3;i.getSize(o);const c=1.2/(o.y||1);s.scale.setScalar(c),t(s)},void 0,s=>e(s))})}return Nn}let On=null;function Xa(){return On||(On=new Promise(y=>{const t=new URL("data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAZAAA/+4AJkFkb2JlAGTAAAAAAQMAFQQDBgoNAAAENwAABZ4AAAb5AAAIwP/bAIQAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAwMDAwMDAwMDAwEBAQEBAQECAQECAgIBAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD/8IAEQgAQABAAwERAAIRAQMRAf/EAO4AAAICAwADAAAAAAAAAAAAAAgJAAcFBgoCAwQBAAIDAQEBAQAAAAAAAAAAAAYHAAUIAwQCCRAAAQEGBgEEAQUAAAAAAAAAABMBEQIEFAUQEgMVBgc1ICEiJSQjNBY2FxEAAAIGBAoHCQAAAAAAAAAAADEQARECBAUyA7UGIaHBEqIUtBXFFiBRU7NVhQexUjNU1HU2hpYSAAADBQUFBgcAAAAAAAAAAAECAwAQIIKyEVGBscHwcRKzBCExYdFywvFSkhMzY4MTAAECAwcEAwEAAAAAAAAAAAABEfBRcRAhMUFhkcEg0eHxgaGxMP/aAAwDAQACEQMRAAABemFW0kVGeClF2nhLQZKy0GSxLfh3vrzY/MV5mTGxJFf6QUtKGFCXYubF2LGyO/NtH4Wj+crrcIv+SLF2FnylmCKGOKsIxhVhIn4ao9zLwI5bBOnJIqzZWY6OYgWbwqyzdFmUh3i/M4xMSN9wJrqSD88W4z73ZdCG9rNlsbdg10quUYzHmqYL2bJKIehqeqwU45lY/vPS4aY9sxchxB8Hdk7UkkrRpHhkJit0LqO2TQXhtbPxlzD9+xBJl6STDFTKO9A22M+R20xu78N24hSJUWf/2gAIAQEAAQUCrStOypl/Nag6u1nijCrKgriuOxJp/Mag6rmBcqioKsqzsOedzCvOppzOVJVlQVZVnZFwy803E6bns5VFWVBVlWXub+z6yuyXCLlNK9sVB/nvXIqbhCbhCXmcfcuB3TJxRsyp2GubiwVN0N0LhPZ5vh9ybBx2S126vMM7TexU3U3U1Z7PHwuPPxm1/wBqP5KwVP/aAAgBAgABBQKuK4k4lZZxcWYOwryvLDEraXFyYOHejizPonFzYOHejingC5Dh3os7PrtW6U0ctOM1NOqYOHicQnEWeH628+SltZK21g4eUxTFugyyd78prxthtqsZlHlMUxLQZdG++VmfGmQef//aAAgBAwABBQJERJn46zy2e44UwQEC5/GeeWf3HCmCYmXv43R5YfcyimCYmchgbvGVpx2EyimCYmWyLLI8pllb7J6LtJI3GfwfCPhJSN0vdtJS4S2l+oiPwWFiT1fxpjSU1ZeBjJvIwfgsLEhqfiPeaP74fh//2gAIAQICBj8CcU99ubiY6RJHv4qzOJjpEhPzDOJjpEhPzDOJjpEnNULChd8W+982nZEnNULKS0gyHjx1REDfmLKS0g3S2fsqiANu9lZaCt0v9KoP/9oACAEDAgY/AnCXbucfDWI5d1IOUl1iVD00g5WX3RKy0FctL7oiF31Cy6l/ByytwXO/Ot9ZvOAtnjmyh91IMct1kRcc2EzLh6Moi45i1rdRJTB//9oACAEBAQY/AkTpf26yYFE88s4h0DBicLb4fZcEie+WcQQYMGDE3U35Cy4IGJ/hLdXEgYNBgxOVN8OsqBBi8eEt0cUBg0GDETh7HZ6oSRzOLeWObx68o9T65vxOS9G7bjuQGPwK5X8tI/oUGDEStvY9xVCVO5xa9jmUYseoFa2nypoyTNQaKQpCteaeZ3bihL3erW9uiVi+lZ7/AC7oyt53IinjRSFILeabPYpQlr3Xrm3xShfD9fs6sRTxo//aAAgBAQMBPyFk0GTQvcx4pUJ4+H6sVRUQuQuTITSTK/sex7zX0x8ktk40X+FhE5Xb6GRZpr8jfc5Cz8LKBysjcjey1RZSUgXzgZ2+AdRFUiqIpFxZtI+7RAOY5M6fjFZpdxsyJyJz7GMuII2VW1M+UPVV70JrjZA2ZA5A59jSXEM6+HjW/RfKz//aAAgBAgMBPyFgwiEZSW4NZYqKiM1kP4RDy3SathxxSDXQSi2ra1xYaL5l+07hJripRRG9Gl0QXEdxEcALllVtQUGnorqI5nOPoigoNH3/AEXSEPp6L//aAAgBAwMBPyF48Rpzfjq2KCgRpX9ZzcXQMUlIkRSyamLqg0qJDgyPAvEXqqj+lB6KDB3DXDikOb0XoqyseUheEJu34iCpcuXodZWPriUETq6P/9oADAMBAAIRAxEAABBtoisla87a0kT/AET6S0W0b6tYt/VNAHcw/9oACAEBAwE/EIJCCQSYGgzXS2g32TsXh2K/Toa30gyXcbL9FTd3Km7uY2sz9BoQ+xSesY3I38kMKROpE6iLYqrmryNk3USzMhSM9iD2Ku4+TdB8m6CxUOQGj3CV2hSWjv4GezuQupEwiYIquqFmcpIRKtydIGzemGW6SmwDp9/NmJsu5AQQEGWXFCj7Qu/pltRskNJzK9xx5sau/gjvcguNh7jYe4heHN/XBQduKpcvzDUJDzCd1Zne/Aarc9I7kFyrCpVhUxnZqiF9M1i9uXoaA2a/Xc//2gAIAQIDAT8Q1UNVBtr0gag4VQbx1hnuM9xJ9eAPgYN2U+Qw45cMWgkRoH2WDC+Vjbp5CwdZcezoLsSi4TyhXIRUdfDYWTQTYcaBoGEqDTgX67QjcfDyMHjw8KMvlX5s11BXM+O4aw0fbVwLcqnIljbHKFHn/9oACAEDAwE/ENI0hZc9qnJ8RfxC4qGGhoyo5FeSsrWGizeUFBSH7X5sI+GyVHyHBwc0RB1NjNtnfMYbIbISjBVeRr0VRIgkouMbTWwM1qrFXR3WPx8QwN5UUWWInInEn7Ea1cfz4hhPfuoaAyYw8PC71iRzq9WgNGP/2Q==",import.meta.url).toString();new g.TextureLoader().load(t,n=>{try{n.colorSpace=g.SRGBColorSpace??g.sRGBEncoding}catch{}y(n)},void 0,()=>y(null))})),On}class Ya{constructor(t,e,n,s,i,o){j(this,"body");j(this,"mesh");j(this,"wanderTimer",0);j(this,"pathTimer",0);j(this,"target",null);j(this,"lastCatPos",null);j(this,"wallCommitTimer",0);j(this,"wallCommitDir",null);j(this,"fleeCommitTimer",0);j(this,"fleeCommitDir",null);j(this,"heading",new g.Vector3(1,0,0));j(this,"flipRetryTimer",0);j(this,"slowTimer",0);j(this,"turnCooldown",0);j(this,"forwardBlockTimer",0);j(this,"speed",10);j(this,"alive",!0);j(this,"holeIgnoreTimer",0);j(this,"holes");j(this,"inHoleTimer",0);j(this,"pendingExitHole",null);j(this,"erraticTimer",0);j(this,"erraticAngle",0);j(this,"wasPursued",!1);j(this,"wanderJitterTimer",0);this.world=t,this.scene=e,this.bounds=s,this.sfx=o;const r=new xn(.24);this.body=new H({mass:.3,shape:r,position:new d(n.x,.36,n.z)}),this.body.linearDamping=.2,t.addBody(this.body);const a=new g.Group;this.mesh=a,e.add(a),Promise.all([Ka(),Za()]).then(([l,u])=>{const h=l.clone(!0);h.traverse(w=>{if(w.isMesh&&(w.castShadow=!0,w.receiveShadow=!0,u)){const m=w.material,v=x=>{x&&"map"in x&&(x.map=u,"side"in x&&(x.side=g.DoubleSide),"needsUpdate"in x&&(x.needsUpdate=!0))};Array.isArray(m)?m.forEach(v):v(m)}});const f=new g.Box3().setFromObject(h),p=f.getCenter(new g.Vector3);h.position.x-=p.x,h.position.z-=p.z,h.position.y-=f.min.y,a.add(h)});const c=lt(0,Math.PI*2);this.heading.set(Math.sin(c),0,Math.cos(c)),this.holes=i}update(t,e){var f;if(!this.alive)return;if(this.inHoleTimer>0)if(this.inHoleTimer=Math.max(0,this.inHoleTimer-t),this.body.velocity.x=0,this.body.velocity.z=0,this.inHoleTimer===0&&this.pendingExitHole)this.performHoleExit(this.pendingExitHole),this.pendingExitHole=null;else return;this.holeIgnoreTimer=Math.max(0,this.holeIgnoreTimer-t),this.wanderTimer-=t,this.pathTimer-=t,this.flipRetryTimer=Math.max(0,this.flipRetryTimer-t);const n=new g.Vector3(this.body.position.x,0,this.body.position.z);let s=new g.Vector3;if(!this.target||this.pathTimer<=0||this.target.distanceTo(n)<.3){const w=lt(this.bounds.min.x+.4,this.bounds.max.x-.4),m=lt(this.bounds.min.z+.4,this.bounds.max.z-.4);this.target=new g.Vector3(w,0,m),this.pathTimer=lt(3,7)}this.target&&s.copy(this.target).sub(n).normalize();const r=n.distanceTo(e)<7;if(r&&!this.wasPursued){(f=this.sfx)==null||f.mouseSqueek(),s.lengthSq()>1e-4||s.set(1,0,0);const w=90*Math.PI/180,m=(Math.random()*2-1)*w,v=Math.sin(m),x=Math.cos(m),M=s.x*x-s.z*v,E=s.x*v+s.z*x,P=new g.Vector3(M,0,E).normalize(),S=lt(1.2,2.5),V=this.bounds,O=.8,K=Ce(n.x+P.x*S,V.min.x+O,V.max.x-O),I=Ce(n.z+P.z*S,V.min.z+O,V.max.z-O);this.target=new g.Vector3(K,0,I),s.copy(P)}if(r){if(this.erraticTimer-=t,this.erraticTimer<=0){const p=60*Math.PI/180;this.erraticAngle=(Math.random()*2-1)*p,this.erraticTimer=.2}if(s.lengthSq()>1e-4){const p=Math.sin(this.erraticAngle),w=Math.cos(this.erraticAngle),m=s.x*w-s.z*p,v=s.x*p+s.z*w;s.set(m,0,v).normalize()}}else if(this.erraticAngle=0,this.erraticTimer=Math.max(this.erraticTimer,0),this.wanderJitterTimer-=t,this.wanderJitterTimer<=0&&s.lengthSq()>1e-4){const p=15*Math.PI/180,w=(Math.random()*2-1)*p,m=Math.sin(w),v=Math.cos(w),x=s.x*v-s.z*m,M=s.x*m+s.z*v;s.set(x,0,M).normalize(),this.wanderJitterTimer=.25}if(this.holeIgnoreTimer<=0&&this.holes&&this.holes.length>0){const p=r?12:6,w=new g.Vector3(this.body.position.x,.5,this.body.position.z);let m=null,v=1/0;for(const x of this.holes){if(!x.room.containsPoint(w))continue;const M=w.distanceTo(x.position);M<v&&(v=M,m=x)}if(m&&v<=p){const x=m.position.clone().addScaledVector(m.inward,-.1);this.target=x;const M=new g.Vector3(this.body.position.x,0,this.body.position.z);s.copy(x).sub(M).normalize()}}const a=this.body.velocity,c=s.lengthSq()>1e-4?Math.max(0,a.x*s.x+a.z*s.z):0;if(s.lengthSq()>1e-4){if(c>=this.speed*.9)this.slowTimer=0;else if(this.slowTimer+=t,this.slowTimer>=.25&&this.flipRetryTimer<=0){const p=Math.random()<.5,w=s.clone();p?w.x*=-1:w.z*=-1;const m=lt(1.2,2.5),v=this.bounds,x=.8,M=Ce(n.x+w.x*m,v.min.x+x,v.max.x-x),E=Ce(n.z+w.z*m,v.min.z+x,v.max.z-x);this.target=new g.Vector3(M,0,E),this.flipRetryTimer=.1,this.slowTimer=0,s.copy(w)}}let l=1.2;if(r&&(l*=1.75),a.x+=(s.x*this.speed*l-a.x)*.2,a.z+=(s.z*this.speed*l-a.z)*.2,this.holeIgnoreTimer<=0&&this.holes&&this.holes.length>0){const p=new g.Vector3(this.body.position.x,0,this.body.position.z);let w=null;for(const m of this.holes){const v=m.inward.clone().setY(0).normalize(),x=new g.Vector3(-v.z,0,v.x).normalize(),M=p.clone().sub(m.position),E=Math.abs(M.x*x.x+M.z*x.z),P=M.x*v.x+M.z*v.z;if(E<=.18&&P>=0&&P<=.9){w=m;break}}w&&this.teleportFromHole(w)}const u=this.bounds;if(a.x+=(n.x<u.min.x+.5?1:0)+(n.x>u.max.x-.5?-1:0),a.z+=(n.z<u.min.z+.5?1:0)+(n.z>u.max.z-.5?-1:0),this.mesh.position.set(this.body.position.x,.24,this.body.position.z),Math.hypot(a.x,a.z)>.05){const p=Math.atan2(a.x,a.z),w=this.mesh.rotation.y;let m=p-w;for(;m>Math.PI;)m-=Math.PI*2;for(;m<-Math.PI;)m+=Math.PI*2;this.mesh.rotation.y=w+m*Math.min(1,t*8)}this.wasPursued=r}teleportFromHole(t){const e=this.holes;let n=e[Math.floor(Math.random()*e.length)];if(e.length>1)for(let s=0;s<4&&n===t;s++)n=e[Math.floor(Math.random()*e.length)];this.inHoleTimer=.25,this.pendingExitHole=n,this.mesh.visible=!1,this.body.velocity.x=0,this.body.velocity.z=0}performHoleExit(t){const e=t.inward.clone().setY(0).normalize(),s=t.position.clone().addScaledVector(e,.6);this.body.position.set(s.x,.36,s.z),this.mesh.visible=!0;const o=75*(Math.random()*2-1)*Math.PI/180,r=Math.cos(o),a=Math.sin(o),c=new g.Vector3(e.x*r+e.z*a,0,e.z*r-e.x*a).normalize(),l=this.speed*1.5;this.body.velocity.x=c.x*l,this.body.velocity.z=c.z*l,this.target=s.clone().addScaledVector(c,2+Math.random()),this.pathTimer=1,this.holeIgnoreTimer=2}kill(){this.alive=!1,this.mesh.visible=!1,this.world.removeBody(this.body)}}let qn=null;function Ka(){if(!qn){const y=new $s;qn=new Promise((t,e)=>{const n=new URL("/assets/mouse-exported-CiP-23e1.fbx",import.meta.url).toString();y.load(n,s=>{const i=new g.Box3().setFromObject(s),o=new g.Vector3;i.getSize(o);const c=.2/(o.y||1);s.scale.setScalar(c),t(s)},void 0,s=>e(s))})}return qn}let Gn=null;function Za(){return Gn||(Gn=new Promise(y=>{const t=new URL("/assets/mouse-DPwdywtM.png",import.meta.url).toString();new g.TextureLoader().load(t,n=>{try{n.colorSpace=g.SRGBColorSpace??g.sRGBEncoding}catch{}y(n)},void 0,()=>y(null))})),Gn}class Qa{constructor(t,e,n=Math.random()*1e9){j(this,"roomBoxes",[]);j(this,"worldBounds");j(this,"floorBody");j(this,"meshes",[]);j(this,"bodies",[]);j(this,"spawnPoints",[]);j(this,"dynamicPairs",[]);j(this,"pausedBodies",new Set);j(this,"mouseHoles",[]);this.world=t,this.scene=e,this.rngSeed=n,this.worldBounds=new g.Box3(new g.Vector3(-20,0,-20),new g.Vector3(20,5,20));const s=new Oo;this.floorBody=new H({mass:0}),this.floorBody.addShape(s),this.floorBody.quaternion.setFromEuler(-Math.PI/2,0,0),t.addBody(this.floorBody);const i=new g.Mesh(new g.PlaneGeometry(100,100),new g.MeshStandardMaterial({color:11121823}));i.rotation.x=-Math.PI/2,i.receiveShadow=!0,e.add(i),this.meshes.push(i)}update(t,e){const o=Math.max(0,10);for(const r of this.dynamicPairs){if(e){const l=r.body.position.x-e.x,u=r.body.position.z-e.z,h=Math.hypot(l,u),f=this.pausedBodies.has(r.body);!f&&h>14?(r.body.velocity.set(0,0,0),r.body.angularVelocity.set(0,0,0),r.body.sleep&&r.body.sleep(),this.pausedBodies.add(r.body)):f&&h<o&&(r.body.wakeUp&&r.body.wakeUp(),this.pausedBodies.delete(r.body))}const a=r.body.position,c=r.body.quaternion;r.mesh.position.set(a.x,a.y,a.z),r.mesh.quaternion&&r.mesh.quaternion.set(c.x,c.y,c.z,c.w)}}dispose(){for(const t of this.bodies)this.world.removeBody(t);for(const t of this.meshes)this.scene.remove(t);this.bodies.length=0,this.meshes.length=0,this.roomBoxes.length=0,this.spawnPoints.length=0}generate(t){for(let b=this.meshes.length-1;b>=1;b--)this.scene.remove(this.meshes[b]),this.meshes.splice(b,1);for(const b of this.bodies)this.world.removeBody(b);this.bodies.length=0,this.roomBoxes.length=0,this.spawnPoints.length=0,this.mouseHoles.length=0;const e=Math.max(8,t.houseHalfSize||10),n=new g.Vector3(-e,0,-e),s=new g.Vector3(e,3,e),i=new g.Box3(n.clone(),s.clone()),o=[];let r=[i];const c=1.2*2+.6,l=(s.x-n.x)*(s.z-n.z),u=typeof t.roomDensity=="number"&&t.roomDensity>0?t.roomDensity:Math.max(.002,t.roomCount/Math.max(1,l)),h=Math.max(1,Math.min(48,Math.floor(l*u)));let f=0;for(;r.length+o.length<h&&f++<500;){let b=-1,L=-1;for(let A=0;A<r.length;A++){const B=r[A],G=new g.Vector3().subVectors(B.max,B.min),q=G.x*G.z;q>L&&(L=q,b=A)}if(b<0)break;const C=r.splice(b,1)[0],D=new g.Vector3().subVectors(C.max,C.min);let Y=D.x>D.z,N=!1;for(let A=0;A<8&&!N;A++)if(A<4?Y:!Y){const G=C.min.x+c,q=C.max.x-c;if(q-G<=.5)continue;const Z=lt(G,q),Q=new g.Box3(C.min.clone(),new g.Vector3(Z,C.max.y,C.max.z)),F=new g.Box3(new g.Vector3(Z,C.min.y,C.min.z),C.max.clone()),U=new g.Vector3().subVectors(Q.max,Q.min),J=new g.Vector3().subVectors(F.max,F.min);U.x>=c&&U.z>=c&&J.x>=c&&J.z>=c&&(r.push(Q,F),N=!0)}else{const G=C.min.z+c,q=C.max.z-c;if(q-G<=.5)continue;const Z=lt(G,q),Q=new g.Box3(C.min.clone(),new g.Vector3(C.max.x,C.max.y,Z)),F=new g.Box3(new g.Vector3(C.min.x,C.min.y,Z),C.max.clone()),U=new g.Vector3().subVectors(Q.max,Q.min),J=new g.Vector3().subVectors(F.max,F.min);U.x>=c&&U.z>=c&&J.x>=c&&J.z>=c&&(r.push(Q,F),N=!0)}N||o.push(C)}o.push(...r),this.roomBoxes=o;const p=7.5,w=.35,m=new g.MeshStandardMaterial({color:15788758,roughness:.9,metalness:0}),v=new g.MeshStandardMaterial({color:16777215,roughness:.7,metalness:0}),x=(b,L,C)=>{const D=new g.Vector3().subVectors(L,b),Y=D.length(),N=Math.atan2(D.x,D.z),A=new g.BoxGeometry(w,C,Y),B=new g.Mesh(A,m);B.position.copy(new g.Vector3().addVectors(b,L).multiplyScalar(.5)),B.position.y=C/2,B.rotation.y=N,B.castShadow=!0,B.receiveShadow=!0,this.scene.add(B),this.meshes.push(B);const G=new Nt(new d(w/2,C/2,Y/2)),q=new H({mass:0,shape:G});q.position.set(B.position.x,B.position.y,B.position.z),q.quaternion.setFromEuler(0,N,0),this.world.addBody(q),this.bodies.push(q)},M=(b,L,C)=>{const D=new g.Vector3().subVectors(L,b),Y=D.length();if(Y<.05)return;const N=Math.atan2(D.x,D.z),A=new g.Vector3().addVectors(b,L).multiplyScalar(.5),B=new g.Vector3(D.z,0,-D.x).normalize(),G=.24,q=.06,Z=w/2+q/2,Q=new g.BoxGeometry(q,G,Math.max(.01,Y-.02)),F=new g.Mesh(Q,v);F.position.copy(A),F.position.y=G/2,F.position.add(B.clone().multiplyScalar(Z)),F.rotation.y=N,F.castShadow=!1,F.receiveShadow=!0;const U=F.clone();U.position.copy(A),U.position.y=G/2,U.position.add(B.clone().multiplyScalar(-Z)),this.scene.add(F),this.meshes.push(F),this.scene.add(U),this.meshes.push(U)},E=(b,L)=>{const C=new g.Vector3().subVectors(L,b),D=C.length();if(D<.05)return;const Y=Math.atan2(C.x,C.z),N=new g.Vector3().addVectors(b,L).multiplyScalar(.5),A=new g.Vector3(C.z,0,-C.x).normalize(),B=.24,G=.06,q=w/2+G/2,Z=new g.BoxGeometry(G,B,Math.max(.01,D-.02)),Q=new g.Vector3((n.x+s.x)/2,0,(n.z+s.z)/2),F=new g.Vector3().subVectors(Q,N).setY(0).normalize(),J=A.dot(F)>0?A:A.clone().multiplyScalar(-1),tt=new g.Mesh(Z,v);tt.position.copy(N),tt.position.y=B/2,tt.position.add(J.clone().multiplyScalar(q)),tt.rotation.y=Y,tt.castShadow=!1,tt.receiveShadow=!0,this.scene.add(tt),this.meshes.push(tt)},P=(b,L)=>{const C=b.min,D=b.max,Y=[new g.Vector3(C.x,0,C.z),new g.Vector3(D.x,0,C.z),new g.Vector3(D.x,0,D.z),new g.Vector3(C.x,0,D.z)],N=[[Y[0],Y[1]],[Y[1],Y[2]],[Y[2],Y[3]],[Y[3],Y[0]]];for(const[A,B]of N){const G=Math.abs(A.z-s.z)<.001&&Math.abs(B.z-s.z)<.001,q=Math.abs(A.z-n.z)<.001&&Math.abs(B.z-n.z)<.001,Z=Math.abs(A.x-s.x)<.001&&Math.abs(B.x-s.x)<.001,Q=Math.abs(A.x-n.x)<.001&&Math.abs(B.x-n.x)<.001,F=!(G||q||Z||Q),U=new g.Vector3().subVectors(B,A),J=U.length(),tt=U.clone().normalize(),ct=.3;let ft=null;for(const Et of L){const mt=new g.Vector3().subVectors(Et,A).dot(tt)/J;if(mt<=.05||mt>=.95)continue;const Lt=A.clone().addScaledVector(tt,mt*J),Tt=Et.clone().sub(Lt);if(Math.abs(Tt.x)+Math.abs(Tt.z)<ct){ft=Lt;break}}if(ft){const Gt=ft.clone().addScaledVector(tt,-1.2),mt=ft.clone().addScaledVector(tt,1.2),Lt=Pt=>new g.Vector3(g.MathUtils.clamp(Pt.x,Math.min(A.x,B.x),Math.max(A.x,B.x)),Pt.y,g.MathUtils.clamp(Pt.z,Math.min(A.z,B.z),Math.max(A.z,B.z))),Tt=A.clone(),_t=Lt(Gt),kt=Lt(mt),Dt=B.clone();x(Tt,_t,p),x(kt,Dt,p),F?(M(Tt,_t),M(kt,Dt)):(E(Tt,_t),E(kt,Dt));const ve=1.2*2,rt=p/3,ot=p-rt,Mt=Math.atan2(tt.x,tt.z),It=new g.BoxGeometry(w,rt,ve),yt=new g.Mesh(It,m);yt.position.copy(ft),yt.position.y=ot+rt/2,yt.rotation.y=Mt,yt.castShadow=!0,yt.receiveShadow=!0,this.scene.add(yt),this.meshes.push(yt);const be=new Nt(new d(w/2,rt/2,ve/2)),St=new H({mass:0,shape:be});St.position.set(yt.position.x,yt.position.y,yt.position.z),St.quaternion.setFromEuler(0,Mt,0),this.world.addBody(St),this.bodies.push(St)}else x(A,B,p),F?M(A,B):E(A,B)}},S=o.map(()=>[]),V=.001;for(let b=0;b<o.length;b++)for(let L=b+1;L<o.length;L++){const C=o[b],D=o[L];if(Math.min(C.max.z,D.max.z)-Math.max(C.min.z,D.min.z)>0){if(Math.abs(C.max.x-D.min.x)<V){const A=(Math.max(C.min.z,D.min.z)+Math.min(C.max.z,D.max.z))/2,B=C.max.x,G=new g.Vector3(B,0,A);S[b].push(G),S[L].push(G);continue}if(Math.abs(C.min.x-D.max.x)<V){const A=(Math.max(C.min.z,D.min.z)+Math.min(C.max.z,D.max.z))/2,B=C.min.x,G=new g.Vector3(B,0,A);S[b].push(G),S[L].push(G);continue}}if(Math.min(C.max.x,D.max.x)-Math.max(C.min.x,D.min.x)>0){if(Math.abs(C.max.z-D.min.z)<V){const A=(Math.max(C.min.x,D.min.x)+Math.min(C.max.x,D.max.x))/2,B=C.max.z,G=new g.Vector3(A,0,B);S[b].push(G),S[L].push(G);continue}if(Math.abs(C.min.z-D.max.z)<V){const A=(Math.max(C.min.x,D.min.x)+Math.min(C.max.x,D.max.x))/2,B=C.min.z,G=new g.Vector3(A,0,B);S[b].push(G),S[L].push(G);continue}}}const O=o.findIndex(b=>Math.abs(b.max.z-s.z)<V);if(O>=0){const b=o[O];S[O].push(new g.Vector3((b.min.x+b.max.x)/2,0,b.max.z))}for(let b=0;b<o.length;b++)P(o[b],S[b]);if(this.spawnPoints.length>0){const Y=N=>{let A=-1;for(let q=0;q<o.length;q++){const Z=o[q];if(N.x>=Z.min.x&&N.x<=Z.max.x&&N.z>=Z.min.z&&N.z<=Z.max.z){A=q;break}}if(A<0)return!0;const B=o[A],G=S[A];for(const q of G)if(Math.abs(q.z-B.max.z)<.001&&N.z<=B.max.z&&N.z>=B.max.z-.8&&N.x>=q.x-1.6&&N.x<=q.x+1.6||Math.abs(q.z-B.min.z)<.001&&N.z>=B.min.z&&N.z<=B.min.z+.8&&N.x>=q.x-1.6&&N.x<=q.x+1.6||Math.abs(q.x-B.max.x)<.001&&N.x<=B.max.x&&N.x>=B.max.x-.8&&N.z>=q.z-1.6&&N.z<=q.z+1.6||Math.abs(q.x-B.min.x)<.001&&N.x>=B.min.x&&N.x<=B.min.x+.8&&N.z>=q.z-1.6&&N.z<=q.z+1.6)return!1;return!0};this.spawnPoints=this.spawnPoints.filter(Y)}const K=[],I=new g.MeshStandardMaterial({color:0,roughness:1,metalness:0}),W=(b,L,C)=>{const D=new g.Vector3().subVectors(C,L);if(D.length()<.8)return;const N=.2+Math.random()*.6,A=L.clone().addScaledVector(D,N),B=Math.atan2(D.x,D.z),G=new g.Vector3().addVectors(L,C).multiplyScalar(.5),q=new g.Vector3(D.z,0,-D.x).normalize(),Z=new g.Vector3((b.min.x+b.max.x)/2,0,(b.min.z+b.max.z)/2),Q=new g.Vector3().subVectors(Z,G).setY(0).normalize(),F=q.dot(Q)>0?q:q.clone().multiplyScalar(-1);{const Pt=Math.abs(L.z-C.z)<.001&&Math.abs(L.z-b.max.z)<.001,Ut=Math.abs(L.z-C.z)<.001&&Math.abs(L.z-b.min.z)<.001,Ct=Math.abs(L.x-C.x)<.001&&Math.abs(L.x-b.max.x)<.001,ie=Math.abs(L.x-C.x)<.001&&Math.abs(L.x-b.min.x)<.001;let Me=!1;for(const ht of K){if(Pt&&Math.abs(ht.z+ht.halfZ-b.max.z)<.2&&A.x>=ht.x-ht.halfX-.06&&A.x<=ht.x+ht.halfX+.06){Me=!0;break}if(Ut&&Math.abs(ht.z-ht.halfZ-b.min.z)<.2&&A.x>=ht.x-ht.halfX-.06&&A.x<=ht.x+ht.halfX+.06){Me=!0;break}if(Ct&&Math.abs(ht.x+ht.halfX-b.max.x)<.2&&A.z>=ht.z-ht.halfZ-.06&&A.z<=ht.z+ht.halfZ+.06){Me=!0;break}if(ie&&Math.abs(ht.x-ht.halfX-b.min.x)<.2&&A.z>=ht.z-ht.halfZ-.06&&A.z<=ht.z+ht.halfZ+.06){Me=!0;break}}if(Me)return}const U=.001,J=o.indexOf(b);if(J>=0){const be=S[J],St=1.2,Pt=.4;let Ut=!1;for(const Ct of be){if(Math.abs(A.z-b.max.z)<U&&Math.abs(Ct.z-b.max.z)<U&&A.x>=Ct.x-(St+Pt)&&A.x<=Ct.x+(St+Pt)){Ut=!0;break}if(Math.abs(A.z-b.min.z)<U&&Math.abs(Ct.z-b.min.z)<U&&A.x>=Ct.x-(St+Pt)&&A.x<=Ct.x+(St+Pt)){Ut=!0;break}if(Math.abs(A.x-b.max.x)<U&&Math.abs(Ct.x-b.max.x)<U&&A.z>=Ct.z-(St+Pt)&&A.z<=Ct.z+(St+Pt)){Ut=!0;break}if(Math.abs(A.x-b.min.x)<U&&Math.abs(Ct.x-b.min.x)<U&&A.z>=Ct.z-(St+Pt)&&A.z<=Ct.z+(St+Pt)){Ut=!0;break}}if(Ut)return}const tt=.02,ct=.36,ft=.3,Et=ct/2,Gt=.85,mt=new g.Group,Lt=new g.BoxGeometry(tt,ft,ct),Tt=new g.Mesh(Lt,I);Tt.position.set(0,ft/2,0),mt.add(Tt);const _t=new g.CylinderGeometry(Et,Et,tt,24),kt=new g.Mesh(_t,I);kt.rotation.z=Math.PI/2;const Dt=Et*Gt;kt.position.set(0,ft+Et-Dt,0),mt.add(kt),mt.position.copy(A),mt.position.y=0;const ve=w/2+tt/2+.002;mt.position.add(F.clone().multiplyScalar(ve)),mt.rotation.y=B,mt.position.y+=.001,this.scene.add(mt),this.meshes.push(mt),this.mouseHoles.push({position:mt.position.clone(),inward:F.clone(),room:b});const rt=.06,ot=.24,Mt=new g.BoxGeometry(rt+.005,ot,ct*.9),It=new g.Mesh(Mt,I);It.position.copy(A),It.position.y=ot/2+.001;const yt=w/2+(rt+.005)/2+.001;It.position.add(F.clone().multiplyScalar(yt)),It.rotation.y=B,this.scene.add(It),this.meshes.push(It)};for(let b=0;b<o.length;b++){const L=o[b],C=L.min,D=L.max,Y=[new g.Vector3(C.x,0,C.z),new g.Vector3(D.x,0,C.z),new g.Vector3(D.x,0,D.z),new g.Vector3(C.x,0,D.z)],N=[[Y[0],Y[1]],[Y[1],Y[2]],[Y[2],Y[3]],[Y[3],Y[0]]];for(const[A,B]of N){const G=Math.abs(A.z-s.z)<.001&&Math.abs(B.z-s.z)<.001,q=Math.abs(A.z-n.z)<.001&&Math.abs(B.z-n.z)<.001,Z=Math.abs(A.x-s.x)<.001&&Math.abs(B.x-s.x)<.001,Q=Math.abs(A.x-n.x)<.001&&Math.abs(B.x-n.x)<.001;G||q||Z||Q||Math.random()<.25&&W(L,A,B)}}const _=3;if(this.mouseHoles.length<_){const b=[];for(let L=0;L<o.length;L++){const C=o[L],D=C.min,Y=C.max,N=[new g.Vector3(D.x,0,D.z),new g.Vector3(Y.x,0,D.z),new g.Vector3(Y.x,0,Y.z),new g.Vector3(D.x,0,Y.z)],A=[[N[0],N[1]],[N[1],N[2]],[N[2],N[3]],[N[3],N[0]]];for(const[B,G]of A){const q=Math.abs(B.z-s.z)<.001&&Math.abs(G.z-s.z)<.001,Z=Math.abs(B.z-n.z)<.001&&Math.abs(G.z-n.z)<.001,Q=Math.abs(B.x-s.x)<.001&&Math.abs(G.x-s.x)<.001,F=Math.abs(B.x-n.x)<.001&&Math.abs(G.x-n.x)<.001;q||Z||Q||F||b.push({room:C,a:B,b:G})}}for(let L=0;L<b.length&&this.mouseHoles.length<_;L++){const C=Math.floor(Math.random()*b.length),D=b[C];W(D.room,D.a,D.b)}}const z=.2,R=10,k=new g.Vector3(n.x+w,0,s.z+z),T=new g.Vector3(s.x-w,0,s.z+z+R),it=1.2,nt=new g.MeshStandardMaterial({color:9075291}),et=(b,L)=>{const C=new g.Vector3().subVectors(L,b),D=C.length(),Y=Math.atan2(C.x,C.z),N=new g.BoxGeometry(.15,it,D),A=new g.Mesh(N,nt);A.position.copy(new g.Vector3().addVectors(b,L).multiplyScalar(.5)),A.position.y=it/2,A.rotation.y=Y,this.scene.add(A),this.meshes.push(A);const B=new Nt(new d(.075,it/2,D/2)),G=new H({mass:0,shape:B});G.position.set(A.position.x,A.position.y,A.position.z),G.quaternion.setFromEuler(0,Y,0),this.world.addBody(G),this.bodies.push(G)};et(new g.Vector3(T.x,0,k.z),new g.Vector3(T.x,0,T.z)),et(new g.Vector3(T.x,0,T.z),new g.Vector3(k.x,0,T.z)),et(new g.Vector3(k.x,0,T.z),new g.Vector3(k.x,0,k.z));const pt=new g.MeshStandardMaterial({color:13150590}),wt=new g.MeshStandardMaterial({color:15132390});for(const b of o){const L=new g.Vector3().subVectors(b.max,b.min),C=new g.Mesh(new g.BoxGeometry(L.x,.1,L.z),pt);C.position.set((b.min.x+b.max.x)/2,.05,(b.min.z+b.max.z)/2),C.receiveShadow=!0,this.scene.add(C),this.meshes.push(C);const D=new Nt(new d(L.x/2,.05,L.z/2)),Y=new H({mass:0,shape:D});Y.position.set(C.position.x,C.position.y,C.position.z),this.world.addBody(Y),this.bodies.push(Y);const N=new g.Mesh(new g.BoxGeometry(L.x,.1,L.z),wt);N.position.set((b.min.x+b.max.x)/2,p-.05,(b.min.z+b.max.z)/2),N.receiveShadow=!1,N.castShadow=!1,this.scene.add(N),this.meshes.push(N);const A=new H({mass:0,shape:new Nt(new d(L.x/2,.05,L.z/2))});A.position.set(N.position.x,N.position.y,N.position.z),this.world.addBody(A),this.bodies.push(A);for(let B=0;B<5;B++){const G=lt(b.min.x+.5,b.max.x-.5),q=lt(b.min.z+.5,b.max.z-.5);this.spawnPoints.push(new g.Vector3(G,0,q))}}const $=new g.Vector3().subVectors(T,k),At=new g.Mesh(new g.BoxGeometry($.x,.1,$.z),new g.MeshStandardMaterial({color:11061129}));At.position.set((k.x+T.x)/2,.05,(k.z+T.z)/2),At.receiveShadow=!0,this.scene.add(At),this.meshes.push(At);const qt=new H({mass:0,shape:new Nt(new d($.x/2,.05,$.z/2))});qt.position.set(At.position.x,At.position.y,At.position.z),this.world.addBody(qt),this.bodies.push(qt),new g.MeshStandardMaterial({color:9132587}),new g.MeshStandardMaterial({color:5597999}),new g.MeshStandardMaterial({color:3821675}),new g.MeshStandardMaterial({color:8026746});const se=(b,L=.9,C=.8)=>{const D=new g.Group,Y=new g.MeshStandardMaterial({color:7043727,roughness:.9}),N=new g.MeshStandardMaterial({color:6056570,roughness:.9}),A=new g.MeshStandardMaterial({color:7820595,roughness:.7,metalness:0}),B=.4,G=C-B,q=Math.min(.18,Math.max(.12,b*.08)),Z=.1,Q=new g.Mesh(new g.BoxGeometry(b,.08,L),A);Q.position.set(0,.08/2+Z,0),Q.castShadow=Q.receiveShadow=!0,D.add(Q);const F=new g.Mesh(new g.BoxGeometry(b-q*2,B,L-.06,2,1,2),Y);F.position.set(0,Z+.08+B/2,0),F.castShadow=F.receiveShadow=!0,D.add(F);const U=new g.Mesh(new g.BoxGeometry(b-q*2,G,.12),N);U.position.set(0,Z+.08+B+G/2,-(L/2)+.06),U.castShadow=U.receiveShadow=!0,D.add(U);const J=new g.Mesh(new g.BoxGeometry(q,C,L),N);J.position.set(-(b/2)+q/2,Z+C/2,0);const tt=J.clone();tt.position.x=b/2-q/2,D.add(J,tt);const ct=b>2.4?3:2;for(let Tt=0;Tt<ct;Tt++){const _t=(b-q*2-.06*(ct+1))/ct,kt=new g.Mesh(new g.BoxGeometry(_t,B*.95,L-.08,2,1,2),Y);kt.position.set(-(b/2-q)+.06+_t/2+Tt*(_t+.06),Z+.08+B/2+.01,.01),kt.castShadow=kt.receiveShadow=!0,D.add(kt)}const ft=new g.CylinderGeometry(.035,.035,Z,8),Et=new g.Mesh(ft,A),Gt=Et.clone(),mt=Et.clone(),Lt=Et.clone();return Et.position.set(-b/2+.08,Z/2,-L/2+.08),Gt.position.set(b/2-.08,Z/2,-L/2+.08),mt.position.set(-b/2+.08,Z/2,L/2-.08),Lt.position.set(b/2-.08,Z/2,L/2-.08),D.add(Et,Gt,mt,Lt),D},jt=(b,L,C,D,Y)=>{for(const G of L)if(C===0&&Math.abs(G.z-b.max.z)<.15&&Math.abs(D-G.x)<Y+1.2+.6||C===1&&Math.abs(G.z-b.min.z)<.15&&Math.abs(D-G.x)<Y+1.2+.6||C===2&&Math.abs(G.x-b.max.x)<.15&&Math.abs(D-G.z)<Y+1.2+.6||C===3&&Math.abs(G.x-b.min.x)<.15&&Math.abs(D-G.z)<Y+1.2+.6)return!0;return!1},Qt=(b,L,C,D)=>!(L.x<C.x||b.x>D.x||L.y<C.y||b.y>D.y),Oe=(b,L,C,D,Y,N,A)=>{const B=Math.abs(Math.sin(Y))>.5?A/2:N/2,G=Math.abs(Math.sin(Y))>.5?N/2:A/2,q=new g.Vector2(C-B,D-G),Z=new g.Vector2(C+B,D+G),Q=.001,F=1.2,U=1,J=.6;for(const tt of L){if(Math.abs(tt.z-b.max.z)<Q){const ct=new g.Vector2(tt.x-(F+J),b.max.z-U),ft=new g.Vector2(tt.x+(F+J),b.max.z);if(Qt(q,Z,ct,ft))return!0}if(Math.abs(tt.z-b.min.z)<Q){const ct=new g.Vector2(tt.x-(F+J),b.min.z),ft=new g.Vector2(tt.x+(F+J),b.min.z+U);if(Qt(q,Z,ct,ft))return!0}if(Math.abs(tt.x-b.max.x)<Q){const ct=new g.Vector2(b.max.x-U,tt.z-(F+J)),ft=new g.Vector2(b.max.x,tt.z+(F+J));if(Qt(q,Z,ct,ft))return!0}if(Math.abs(tt.x-b.min.x)<Q){const ct=new g.Vector2(b.min.x,tt.z-(F+J)),ft=new g.Vector2(b.min.x+U,tt.z+(F+J));if(Qt(q,Z,ct,ft))return!0}}return!1},qe=(b,L,C,D)=>{for(const N of K)if(!(b+C+.04<N.x-N.halfX||b-C-.04>N.x+N.halfX||L+D+.04<N.z-N.halfZ||L-D-.04>N.z+N.halfZ))return!0;return!1},gn=(b,L)=>{const D=new g.Vector3().subVectors(b.max,b.min),Y=Math.max(D.x,D.z),N=g.MathUtils.clamp((Y-4)/8,0,1),A=(lt(1.6,3.2)+N*lt(.4,1))*1.5,B=(lt(.8,1)+N*lt(0,.2))*1.5,G=.8*1.5,q=se(A,B,G);q.traverse(rt=>{rt.castShadow=!0,rt.receiveShadow=!0});const Z=Math.floor(Math.random()*4),Q=.06;let F=0,U=0,J=0,tt=12,ct=!1;for(;tt-- >0;){if(Z===0){U=b.max.z-(B/2+Q);const rt=b.min.x+.6+A/2,ot=b.max.x-.6-A/2;if(F=lt(rt,Math.max(rt,ot)),J=Math.PI,!jt(b,L,Z,F,A/2)&&!qe(F,U,A/2,B/2)){ct=!0;break}}else if(Z===1){U=b.min.z+(B/2+Q);const rt=b.min.x+.6+A/2,ot=b.max.x-.6-A/2;if(F=lt(rt,Math.max(rt,ot)),J=0,!jt(b,L,Z,F,A/2)&&!qe(F,U,A/2,B/2)){ct=!0;break}}else if(Z===2){F=b.max.x-(B/2+Q);const rt=b.min.z+.6+A/2,ot=b.max.z-.6-A/2;if(U=lt(rt,Math.max(rt,ot)),J=-Math.PI/2,!jt(b,L,Z,U,A/2)&&!qe(F,U,B/2,A/2)){ct=!0;break}}else{F=b.min.x+(B/2+Q);const rt=b.min.z+.6+A/2,ot=b.max.z-.6-A/2;if(U=lt(rt,Math.max(rt,ot)),J=Math.PI/2,!jt(b,L,Z,U,A/2)&&!qe(F,U,B/2,A/2)){ct=!0;break}}if(!ct)return 0}if(q.position.set(F,0,U),q.rotation.y=J,Oe(b,L,F,U,J,A,B))return 0;this.scene.add(q),this.meshes.push(q);const ft=Math.abs(Math.sin(J))>.5?B/2:A/2,Et=Math.abs(Math.sin(J))>.5?A/2:B/2;K.push({x:F,z:U,halfX:ft,halfZ:Et});{const rt=Math.abs(Math.sin(J))>.5?B/2:A/2,ot=Math.abs(Math.sin(J))>.5?A/2:B/2;K.push({x:F,z:U,halfX:rt,halfZ:ot})}const Gt=.1,mt=.08,Lt=.4,Tt=G-Lt,_t=Math.min(.18*(A/(A||1)),Math.max(.12,A*.08)),kt=Gt+mt+Lt,Dt=new H({mass:0});{const rt=Math.max(.2,A-_t*2),ot=Math.max(.2,B-.06),Mt=.12,It=new Nt(new d(rt/2,Mt/2,ot/2)),yt=new d(0,kt-Mt/2,0);Dt.addShape(It,yt)}{const rt=Math.max(.2,A-_t*2),ot=.12,Mt=new Nt(new d(rt/2,Math.max(.1,Tt)/2,ot/2)),It=Gt+mt+Lt+Math.max(.1,Tt)/2,yt=new d(0,It,-(B/2)+ot/2+.06);Dt.addShape(Mt,yt)}Dt.position.set(F,0,U),q.rotation.y!==0&&Dt.quaternion.setFromEuler(0,q.rotation.y,0),Dt.isCouch=!0,this.world.addBody(Dt),this.bodies.push(Dt);let ve=1;if(Y>6&&Math.random()<.5+N*.3){const rt=1+N*.5,ot=lt(1.2,2.4)*rt*1.5,Mt=lt(.75,.95)*rt*1.5,It=G,yt=se(ot,Mt,It);yt.traverse(ie=>{ie.castShadow=!0,ie.receiveShadow=!0});const be=new g.Vector3(Math.cos(J),0,-Math.sin(J)),St=new g.Vector3(Math.sin(J),0,Math.cos(J)),Pt=ie=>new g.Vector3().copy(new g.Vector3(F,0,U)).add(be.clone().multiplyScalar(ie*A/2)).add(St.clone().multiplyScalar(B/2)),Ut=.06;let Ct=!1;for(const ie of[1,-1]){const Me=Pt(ie),ht=be.clone().multiplyScalar(-ie).normalize(),Te=[J+Math.PI/2,J-Math.PI/2];let Xt=Te[0],$n=-1e9;for(const Ge of Te){const Bt=new g.Vector3(Math.sin(Ge),0,Math.cos(Ge)).dot(ht);Bt>$n&&($n=Bt,Xt=Ge)}const ri=new g.Vector3(Math.cos(Xt),0,-Math.sin(Xt)),ai=new g.Vector3(Math.sin(Xt),0,Math.cos(Xt));for(const Ge of[1,-1]){const Bt=Me.clone().sub(St.clone().multiplyScalar(Ut)).clone().sub(ri.clone().multiplyScalar(Ge*ot/2+Ut)).sub(ai.clone().multiplyScalar(Mt/2+Ut));if(!(Bt.x-ot/2<b.min.x+.5||Bt.x+ot/2>b.max.x-.5)&&!(Bt.z-Mt/2<b.min.z+.5||Bt.z+Mt/2>b.max.z-.5)&&!Oe(b,L,Bt.x,Bt.z,Xt,ot,Mt)){const Jn=Math.abs(Math.sin(Xt))>.5?Mt/2:ot/2,ts=Math.abs(Math.sin(Xt))>.5?ot/2:Mt/2;if(qe(Bt.x,Bt.z,Jn,ts))continue;yt.position.set(Bt.x,0,Bt.z),yt.rotation.y=Xt,this.scene.add(yt),this.meshes.push(yt);const es=.1,ns=.08,vn=.4,ss=It-vn,is=Math.min(.18*(ot/(ot||1)),Math.max(.12,ot*.08)),li=es+ns+vn,ze=new H({mass:0});{const bn=Math.max(.2,ot-is*2),Je=Math.max(.2,Mt-.06),tn=.12,Mn=new Nt(new d(bn/2,tn/2,Je/2)),zn=new d(0,li-tn/2,0);ze.addShape(Mn,zn)}{const bn=Math.max(.2,ot-is*2),Je=.12,tn=new Nt(new d(bn/2,Math.max(.1,ss)/2,Je/2)),Mn=es+ns+vn+Math.max(.1,ss)/2,zn=new d(0,Mn,-(Mt/2)+Je/2+.06);ze.addShape(tn,zn)}ze.position.set(Bt.x,0,Bt.z),Xt!==0&&ze.quaternion.setFromEuler(0,Xt,0),ze.isCouch=!0,this.world.addBody(ze),this.bodies.push(ze),K.push({x:Bt.x,z:Bt.z,halfX:Jn,halfZ:ts}),Ct=!0,ve+=1;break}}if(Ct)break}}return ve};for(let b=0;b<o.length;b++){const L=o[b];(L.min.x+L.max.x)/2,(L.min.z+L.max.z)/2}const ii=Math.random()<.5?1:2;let $e=0;for(let b=0;b<o.length;b++)Math.random()<.7&&($e+=gn(o[b],S[b])),Math.random()<.35&&($e+=gn(o[b],S[b]));let oi=50;for(;$e<ii&&oi-- >0;){const b=Math.floor(Math.random()*o.length);$e+=gn(o[b],S[b])}if(this.mouseHoles.length>0&&K.length>0){const C=N=>{const A=N.room,B=N.position,G=Math.abs(B.z-A.max.z)<.001,q=Math.abs(B.z-A.min.z)<.001,Z=Math.abs(B.x-A.max.x)<.001,Q=Math.abs(B.x-A.min.x)<.001;for(const F of K)if(G&&Math.abs(F.z+F.halfZ-A.max.z)<.2&&B.x>=F.x-F.halfX-.06&&B.x<=F.x+F.halfX+.06||q&&Math.abs(F.z-F.halfZ-A.min.z)<.2&&B.x>=F.x-F.halfX-.06&&B.x<=F.x+F.halfX+.06||Z&&Math.abs(F.x+F.halfX-A.max.x)<.2&&B.z>=F.z-F.halfZ-.06&&B.z<=F.z+F.halfZ+.06||Q&&Math.abs(F.x-F.halfX-A.min.x)<.2&&B.z>=F.z-F.halfZ-.06&&B.z<=F.z+F.halfZ+.06)return!1;return!0},D=this.mouseHoles.length;this.mouseHoles=this.mouseHoles.filter(C);const Y=Math.max(0,D-this.mouseHoles.length);if(Y>0){const N=[];for(let G=0;G<o.length;G++){const q=o[G],Z=q.min,Q=q.max,F=[new g.Vector3(Z.x,0,Z.z),new g.Vector3(Q.x,0,Z.z),new g.Vector3(Q.x,0,Q.z),new g.Vector3(Z.x,0,Q.z)],U=[[F[0],F[1]],[F[1],F[2]],[F[2],F[3]],[F[3],F[0]]];for(const[J,tt]of U){const ct=Math.abs(J.z-s.z)<.001&&Math.abs(tt.z-s.z)<.001,ft=Math.abs(J.z-n.z)<.001&&Math.abs(tt.z-n.z)<.001,Et=Math.abs(J.x-s.x)<.001&&Math.abs(tt.x-s.x)<.001,Gt=Math.abs(J.x-n.x)<.001&&Math.abs(tt.x-n.x)<.001;ct||ft||Et||Gt||N.push({room:q,a:J,b:tt})}}let A=Y,B=N.length*2+20;for(;A>0&&B-- >0&&N.length>0;){const G=Math.floor(Math.random()*N.length),q=N[G];W(q.room,q.a,q.b);const Z=this.mouseHoles.filter(C),Q=Z.length>this.mouseHoles.length?1:0;this.mouseHoles=Z,Q>0&&(A-=Q)}this.mouseHoles=this.mouseHoles.filter(C)}}this.spawnPoints.length>0&&K.length>0&&(this.spawnPoints=this.spawnPoints.filter(L=>{for(const C of K)if(L.x>=C.x-C.halfX-.1&&L.x<=C.x+C.halfX+.1&&L.z>=C.z-C.halfZ-.1&&L.z<=C.z+C.halfZ+.1)return!1;return!0}));for(let b=0;b<t.clutterCount;b++){const L=Wa(o),C=.6,D=lt(L.min.x+C,L.max.x-C),Y=lt(L.min.z+C,L.max.z-C),N=.15,A=lt(.12,.6)*.25,B=lt(2,3),G=new g.MeshStandardMaterial({color:16777215*Math.random()});if(Math.random()<.5){const Z=lt(.08,.18)*B,Q=new g.Mesh(new g.SphereGeometry(Z,18,14),G);Q.position.set(D,N+Z+.02,Y),Q.castShadow=!0,Q.receiveShadow=!0,this.scene.add(Q),this.meshes.push(Q);const F=new H({mass:A,shape:new xn(Z)});F.angularDamping=.25,F.linearDamping=.02,F.position.set(Q.position.x,Q.position.y,Q.position.z),this.world.addBody(F),this.bodies.push(F),this.dynamicPairs.push({mesh:Q,body:F})}else{const q=lt(.06,.12),Z=lt(.14,.3),Q=q*B,F=Z*B,U=new g.Mesh(new g.CylinderGeometry(Q,Q,F,16),G);U.position.set(D,N+F/2+.02,Y),U.castShadow=!0,U.receiveShadow=!0,this.scene.add(U),this.meshes.push(U);const J=new No(Q,Q,F,16),tt=new H({mass:A}),ct=new bt;ct.setFromEuler(0,0,Math.PI/2),tt.addShape(J,new d(0,0,0),ct),tt.angularDamping=.25,tt.linearDamping=.02,tt.position.set(U.position.x,U.position.y,U.position.z),this.world.addBody(tt),this.bodies.push(tt),this.dynamicPairs.push({mesh:U,body:tt})}}}}class $a{constructor(t=document){j(this,"keys",{});j(this,"mouseDelta",{x:0,y:0});j(this,"wheelDelta",0);j(this,"lockPounce",!1);j(this,"sensitivity",1);j(this,"gpIndex",-1);j(this,"gpDeadzone",.2);j(this,"gpMoveX",0);j(this,"gpMoveY",0);j(this,"gpPrevButtons",[]);j(this,"padRestart",!1);j(this,"padNext",!1);j(this,"padAccept",!1);j(this,"suppressPadJumpLatched",!1);this.dom=t,this.bind()}bind(){this.dom.addEventListener("keydown",t=>{this.keys[t.code]=!0,["KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(t.code)&&t.preventDefault()}),this.dom.addEventListener("keyup",t=>{this.keys[t.code]=!1,t.code==="KeyE"&&(this.lockPounce=!0)}),window.addEventListener("mousemove",t=>{this.mouseDelta.x+=t.movementX,this.mouseDelta.y+=t.movementY}),window.addEventListener("wheel",t=>{this.wheelDelta+=Math.sign(t.deltaY)},{passive:!0}),window.addEventListener("gamepadconnected",t=>{const e=t.gamepad;this.gpIndex<0&&(this.gpIndex=e.index)}),window.addEventListener("gamepaddisconnected",t=>{const e=t.gamepad;this.gpIndex===e.index&&(this.gpIndex=-1)})}consumeMouseDelta(){const t={...this.mouseDelta};return this.mouseDelta.x=0,this.mouseDelta.y=0,t}consumeWheelDelta(){const t=this.wheelDelta;return this.wheelDelta=0,t}consumeLockPounce(){const t=this.lockPounce;return this.lockPounce=!1,t}get forward(){return(this.keys.KeyW?1:0)+(this.keys.ArrowUp?1:0)+Math.max(0,this.gpMoveY)}get backward(){return(this.keys.KeyS?1:0)+(this.keys.ArrowDown?1:0)+Math.max(0,-this.gpMoveY)}get left(){return(this.keys.KeyA?1:0)+(this.keys.ArrowLeft?1:0)+Math.max(0,-this.gpMoveX)}get right(){return(this.keys.KeyD?1:0)+(this.keys.ArrowRight?1:0)+Math.max(0,this.gpMoveX)}get jump(){const t=!!this.keys.Space,e=this.isPadButton(0)&&!this.suppressPadJumpLatched;return t||e}get run(){const t=this.getPadButtonValue(7)>.5||this.isPadButton(5);return!!this.keys.ShiftLeft||!!this.keys.ShiftRight||t}get sneak(){const t=this.getPadButtonValue(6)>.5||this.isPadButton(4);return!!this.keys.ControlLeft||!!this.keys.ControlRight||t}get restart(){return!!this.keys.KeyR||this.padRestart}get next(){return!!this.keys.KeyN||this.padNext}updateGamepad(t=0){const e=navigator.getGamepads?navigator.getGamepads():[];let n=null;if(this.gpIndex>=0&&(n=e[this.gpIndex]||null),!n){for(const v of e)if(v){n=v,this.gpIndex=v.index;break}}if(!n)return;const s=n.axes||[],i=this.gpDeadzone,o=v=>Math.abs(v)<i?0:(v-Math.sign(v)*i)/(1-i),r=o(s[0]||0),a=o(s[1]||0),c=o(s[2]||0),l=o(s[3]||0);this.gpMoveX=r,this.gpMoveY=-a;const u=25*this.sensitivity;this.mouseDelta.x+=c*u,this.mouseDelta.y+=l*u;const h=this.isPadButton(12),f=this.isPadButton(13);h&&(this.wheelDelta-=1),f&&(this.wheelDelta+=1),(this.justPressed(2)||this.justPressed(1))&&(this.lockPounce=!0),this.padRestart=this.justPressed(8),this.padNext=this.justPressed(9),this.padAccept=this.justPressed(0);const w=n.buttons&&n.buttons[0],m=!!(typeof w=="object"?w.pressed:w);this.suppressPadJumpLatched&&!m&&(this.suppressPadJumpLatched=!1),this.gpPrevButtons=(n.buttons||[]).map(v=>typeof v=="object"?v.pressed:!!v)}isPadButton(t){const e=navigator.getGamepads?navigator.getGamepads():[],n=this.gpIndex>=0&&e[this.gpIndex]||null;if(!n)return!1;const s=n.buttons&&n.buttons[t];return s?typeof s=="object"?s.pressed:!!s:!1}getPadButtonValue(t){const e=navigator.getGamepads?navigator.getGamepads():[],n=this.gpIndex>=0&&e[this.gpIndex]||null;if(!n)return 0;const s=n.buttons&&n.buttons[t];return s?typeof s=="object"?s.value??(s.pressed?1:0):s?1:0:0}justPressed(t){const e=navigator.getGamepads?navigator.getGamepads():[],n=this.gpIndex>=0&&e[this.gpIndex]||null;if(!n)return!1;const s=n.buttons&&n.buttons[t],i=typeof s=="object"?s.pressed:!!s,o=this.gpPrevButtons[t]||!1;return i&&!o}consumePadAccept(){const t=this.padAccept;return this.padAccept=!1,t}suppressPadJumpOnce(){this.suppressPadJumpLatched=!0}}const ne={setLevel(y){const t=document.getElementById("level");t&&(t.textContent=String(y))},setCaught(y){const t=document.getElementById("caught");t&&(t.textContent=String(y))},setRequired(y){const t=document.getElementById("required");t&&(t.textContent=String(y))},setRemaining(y){const t=document.getElementById("remaining");t&&(t.textContent=String(y))},setState(y){const t=document.getElementById("state");t&&(t.textContent=y)},setFPS(y){const t=document.getElementById("fps");t&&(t.textContent=y.toFixed(0))},showBanner(y){const t=document.getElementById("banner");t&&(t.innerHTML=y,t.style.display="block")},hideBanner(){const y=document.getElementById("banner");y&&(y.style.display="none")}};class Ja{constructor(){j(this,"ctx",null);j(this,"master",null);j(this,"unlocked",!1);j(this,"buffers",new Map);j(this,"loopSrc",null)}ensure(){if(!this.ctx){const t=window.AudioContext||window.webkitAudioContext;if(!t)return;this.ctx=new t,this.master=this.ctx.createGain(),this.master.gain.value=.6,this.master.connect(this.ctx.destination)}}resume(){this.ensure(),this.ctx&&this.ctx.state!=="running"&&this.ctx.resume(),this.unlocked=!0}boop(){if(this.ensure(),!this.ctx||!this.master||!this.unlocked)return;const t=this.ctx.currentTime,e=this.ctx.createOscillator(),n=this.ctx.createGain();e.type="sine",e.frequency.setValueAtTime(420,t),e.frequency.exponentialRampToValueAtTime(660,t+.09),n.gain.setValueAtTime(.001,t),n.gain.exponentialRampToValueAtTime(.2,t+.01),n.gain.exponentialRampToValueAtTime(1e-4,t+.12),e.connect(n),n.connect(this.master),e.start(t),e.stop(t+.14)}async loadBuffer(t){if(this.ensure(),!this.ctx)return null;if(this.buffers.has(t))return this.buffers.get(t);try{const n=await(await fetch(t)).arrayBuffer(),s=await this.ctx.decodeAudioData(n);return this.buffers.set(t,s),s}catch{return null}}async playSample(t,e=1,n=1){if(this.ensure(),!this.ctx||!this.master||!this.unlocked)return;const s=new URL(t,import.meta.url).toString(),i=await this.loadBuffer(s);if(!i)return;const o=this.ctx.currentTime,r=this.ctx.createBufferSource();r.buffer=i,r.playbackRate.value=n;const a=this.ctx.createGain();a.gain.value=e,r.connect(a),a.connect(this.master),r.start(o)}mouseSqueek(){this.playSample("../sfx/mouse-squeek.wav",.35,1)}mouseDie(){this.playSample("../sfx/mouse-die.wav",.5,1)}catTrill(){this.playSample("../sfx/cat-trill.wav",.08,1)}async startCatPurr(t=.45){if(this.ensure(),!this.ctx||!this.master||!this.unlocked)return;if(this.loopSrc&&this.loopSrc.key==="cat-purr"){this.loopSrc.gain.gain.value=t;return}const e=new URL("/assets/cat-pur-DlHdAjg8.wav",import.meta.url).toString(),n=await this.loadBuffer(e);if(!n)return;const s=this.ctx.createBufferSource();s.buffer=n,s.loop=!0;const i=this.ctx.createGain();i.gain.value=t,s.connect(i),i.connect(this.master),s.start(),this.loopSrc={key:"cat-purr",src:s,gain:i}}stopCatPurr(){if(!(!this.ctx||!this.loopSrc)){try{this.loopSrc.src.stop()}catch{}try{this.loopSrc.src.disconnect(),this.loopSrc.gain.disconnect()}catch{}this.loopSrc=null}}}let _n=null;function tc(){if(!_n){const y=new URL("/assets/star-cropped-CgZ1Ql_d.png",import.meta.url).toString();_n=new Promise((t,e)=>{new g.TextureLoader().load(y,n=>{try{n.colorSpace=g.SRGBColorSpace??g.sRGBEncoding}catch{}t(n)},void 0,n=>e(n))})}return _n}class ec{constructor(t,e){j(this,"particles",[]);j(this,"materialBase",null);j(this,"maxParticles",400);j(this,"warmSprite",null);j(this,"_pendingPrewarm",!1);this.world=t,this.scene=e,tc().then(n=>{this.materialBase=new g.SpriteMaterial({map:n,transparent:!0,depthWrite:!1,opacity:1,blending:g.NormalBlending}),this._pendingPrewarm&&(this._pendingPrewarm=!1,this.prewarm())})}prewarm(){if(this.warmSprite)return;if(!this.materialBase){this._pendingPrewarm=!0;return}const t=this.materialBase.clone();t.opacity=0;const e=new g.Sprite(t);e.renderOrder=-1,e.position.set(0,-10,0),e.scale.set(.1,.1,1),e.visible=!0,this.scene.add(e),this.warmSprite=e}clear(){var t,e,n,s;for(const i of this.particles)this.scene.remove(i.sprite),(e=(t=i.sprite.material).dispose)==null||e.call(t),this.world.removeBody(i.body);this.particles.length=0,this.warmSprite&&(this.scene.remove(this.warmSprite),(s=(n=this.warmSprite.material).dispose)==null||s.call(n),this.warmSprite=null)}spawn(t,e=16){if(!this.materialBase||this.particles.length>=this.maxParticles)return;const n=Math.max(0,this.maxParticles-this.particles.length),s=Math.min(e,n);for(let i=0;i<s;i++){const o=this.materialBase.clone();o.opacity=1;const r=new g.Sprite(o),a=.18+Math.random()*.12;r.scale.set(a,a,1),r.position.set(t.x,Math.max(.1,t.y)+.1,t.z),this.scene.add(r);const c=new xn(a*.25),l=new H({mass:.02,shape:c});l.position.set(r.position.x,r.position.y,r.position.z),l.linearDamping=.15,l.angularDamping=.2;const u=Math.random()*Math.PI*2,h=1+Math.random()*1,f=(1+Math.random()*1.2)*5;l.velocity.set(Math.sin(u)*h,f,Math.cos(u)*h),l.angularVelocity.set((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2),this.world.addBody(l);const p=1.2+Math.random()*.6;this.particles.push({body:l,sprite:r,life:p,total:p})}}update(t){var e,n;if(this.particles.length!==0)for(let s=this.particles.length-1;s>=0;s--){const i=this.particles[s];i.life-=t,i.sprite.position.set(i.body.position.x,i.body.position.y,i.body.position.z);const o=Math.max(0,i.life)/i.total,r=o*o;i.sprite.material.opacity=r,(i.life<=0||i.body.position.y<-1||i.sprite.material.opacity<=.01)&&(this.scene.remove(i.sprite),(n=(e=i.sprite.material).dispose)==null||n.call(e),this.world.removeBody(i.body),this.particles.splice(s,1))}}}const nc=document.getElementById("app"),Ne=new g.WebGLRenderer({antialias:!0});Ne.setSize(window.innerWidth,window.innerHeight);Ne.shadowMap.enabled=!0;nc.appendChild(Ne.domElement);const fe=new g.Scene;fe.background=new g.Color(2240570);const Ke=new g.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,1e3);Ke.position.set(0,2.8,4.2);const sc=new g.HemisphereLight(16777215,4478310,.6);fe.add(sc);const ge=new g.DirectionalLight(16777215,.9);ge.position.set(10,15,8);ge.castShadow=!0;ge.shadow.mapSize.set(2048,2048);ge.shadow.camera.left=-25;ge.shadow.camera.right=25;ge.shadow.camera.top=25;ge.shadow.camera.bottom=-25;fe.add(ge);const ke=ha(),de=new $a(document),Ve=new Ja,De=Ne.domElement;De.style.outline="none";De.tabIndex=0;De.addEventListener("click",()=>{document.pointerLockElement!==De&&De.requestPointerLock(),Ve.resume()});document.addEventListener("pointerlockchange",()=>{const y=document.pointerLockElement===De,t=document.getElementById("lockHint");t&&(t.style.display=y?"none":"block")});const Hn=document.getElementById("sensitivity"),Rs=document.getElementById("sensitivityLabel");if(Hn){const y=()=>{const t=Number(Hn.value);de.sensitivity=isNaN(t)?1:t,Rs&&(Rs.textContent=`${de.sensitivity.toFixed(2)}x`)};y(),Hn.addEventListener("input",y)}const ue=new Qa(ke,fe);let Xe=1;const dn=new ec(ke,fe);dn.prewarm();function Ls(y){const t=4+Math.floor(y*1.5),e=10+Math.min(20,Math.floor(y*2)),n=e/10,s=e*2*(e*2),i=Math.min(14,3+Math.floor(y*.8)+Math.floor((n-1)*3)),o=i/s;return{miceRequired:Math.min(t,4+y),mouseCount:t,mouseSpeed:2.5+y*.2,roomCount:i,clutterCount:Math.floor((20+y*5)*n*n),houseHalfSize:e,roomDensity:o}}let pe,Be=[],Se=0,pn=0,fn=0,hn=!1;function Yn(y){ue.generate(Ls(y)),dn.clear(),Ve.stopCatPurr(),pe&&(fe.remove(pe.mesh),ke.removeBody(pe.body));const t=ue.spawnPoints[Math.floor(Math.random()*ue.spawnPoints.length)]||new g.Vector3(0,0,0);pe=new ja(ke,fe,de,t.clone()),ne.hideBanner(),hn=!1;for(const n of Be)n.alive&&n.kill();Be=[];const e=Ls(y);pn=e.miceRequired;for(let n=0;n<e.mouseCount;n++){const s=ue.spawnPoints[Math.floor(Math.random()*ue.spawnPoints.length)]||new g.Vector3(0,0,0),i=new Ya(ke,fe,s.clone(),ue.worldBounds.clone(),ue.mouseHoles,Ve);i.speed=e.mouseSpeed,Be.push(i)}Se=0,fn=Be.length,ne.setLevel(Xe),ne.setCaught(Se),ne.setRequired(pn),ne.setRemaining(fn)}Yn(Xe);window.addEventListener("resize",()=>{Ke.aspect=window.innerWidth/window.innerHeight,Ke.updateProjectionMatrix(),Ne.setSize(window.innerWidth,window.innerHeight)});let ks=performance.now(),ln=0,Wn=0;function si(){const y=performance.now(),t=Math.min(.033,(y-ks)/1e3);ks=y,ke.step(1/60,t,3),de.updateGamepad(t),hn&&de.padAccept&&de.suppressPadJumpOnce();const e=new g.Vector3(pe.body.position.x,0,pe.body.position.z);ue.update(t,e),dn.update(t),pe.update(t,Ke,Be.filter(s=>s.alive).map(s=>s.mesh),ue.meshes);const n=e.clone();for(const s of Be)s.update(t,n);for(const s of Be){if(!s.alive)continue;if(s.mesh.position.distanceTo(pe.mesh.position)<.7){const o=s.mesh.position.clone();dn.spawn(o,18+Math.floor(Math.random()*10)),s.kill(),Ve.mouseDie(),Ve.catTrill(),Se++,fn--,ne.setCaught(Se),ne.setRemaining(fn),Se>=pn&&!hn&&(ne.showBanner(`<h2>House cleared!</h2><p>You caught ${Se} mice.</p><p>Press <b>N</b> for the next house.</p>`),hn=!0,Ve.startCatPurr())}}if(de.restart&&Yn(Xe),(de.next||de.consumePadAccept())&&Se>=pn&&(Xe++,Yn(Xe)),ne.setState(pe.state),Ne.render(fe,Ke),ln+=t,Wn++,ln>=.5){const s=Wn/ln;ne.setFPS(s),ln=0,Wn=0}requestAnimationFrame(si)}si();
